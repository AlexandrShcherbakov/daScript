options log=true, logStack=true, optimize=true

def pass_array ( arr:array<int> )
    push(arr,4)

[export]
def test
    print("test array:\n")
    let ( arr:array<int>; arr2:array<int>; val2:int=2 )
        assert(length(arr)==0,"array starts at 0 length")
        push(arr,1)
        push(arr,val2)
        push(arr,3)
        assert(length(arr)==3,"array length is 3")
        assert(capacity(arr)==16,"its 2x, but no less than 16")
        debug(arr)
        pass_array(arr)
        assert(length(arr)==4,"array length is 4")
        debug(arr)
        resize(arr,6)
        assert(length(arr)==6,"array length is now 6")
        debug(arr)
        resize(arr,17)
        debug(arr)
        assert(capacity(arr)==32,"now bigger")
        reserve(arr,33)
        debug(arr)
        assert(capacity(arr)==33,"now even bigger")
        resize(arr,4)
        assert(capacity(arr)==33,"did not grow smaller")
        assert(length(arr)==4,"resized properly")
        arr2 <- arr
        assert(length(arr)==0)
        assert(length(arr2)==4)
        let ( index:int = 0 )
            while index < 4
                debug(arr2[index++]++)
        arr <- arr2
        debug(arr)
        resize(arr,3)
        debug(arr)
        resize(arr,4)
        assert(arr[3]==0,"new element after resize is 0")
        debug(arr)
        push(arr,1,0)
        debug(arr)
        resize(arr,4)
        push(arr,5,4)
        debug(arr)
        push(arr,7,2)
        debug(arr)
        erase(arr,2)
        debug(arr)
        erase(arr,0)
        erase(arr,3)
        debug(arr)
    print("ok\n")
    return true
