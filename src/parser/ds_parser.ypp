%define api.prefix {das_yy}
%code requires {
	#include "daScript/misc/platform.h"
	#include "daScript/ast/ast.h"
    #include "daScript/ast/ast_generate.h"
    #include "daScript/ast/ast_expressions.h"

    enum {
        CorM_COPY   = 0,
        CorM_MOVE   = (1<<0),
        CorM_CLONE  = (1<<1)
    };
    
    namespace das {
        extern ProgramPtr			g_Program;
        extern FileAccessPtr        g_Access;
        extern vector<FileInfo *>	g_FileAccessStack;
    }
    using namespace das;
    
    struct VariableDeclaration {
        VariableDeclaration ( const LineInfo & a, vector<string> * n, TypeDecl * t, Expression * i )
            : at(a), pNameList(n), pTypeDecl(t), pInit(i) {}
        virtual ~VariableDeclaration () {
            if ( pNameList ) delete pNameList;
            delete pTypeDecl;
            if ( pInit ) delete pInit;
            if ( annotation ) delete annotation;
        }
        LineInfo                at;
        vector<string>          *pNameList;
        TypeDecl                *pTypeDecl;
        Expression              *pInit;
        bool                    init_via_move = false;
        bool                    init_via_clone = false;
        bool                    override = false;
        AnnotationArgumentList  *annotation = nullptr;
    };
    
    ExprLooksLikeCall * parseFunctionArguments ( ExprLooksLikeCall * pCall, Expression * arguments );
    vector<ExpressionPtr> sequenceToList ( Expression * arguments );
    void deleteVariableDeclarationList ( vector<VariableDeclaration *> * list );
    void varDeclToTypeDecl ( TypeDecl * pType, vector<VariableDeclaration*> * list );
    
    LineInfo tokAt ( const struct YYLTYPE & li );
    
    Annotation * findAnnotation ( const string & name, const LineInfo & at );
}

%{
	#include "daScript/misc/platform.h"
	#include "daScript/simulate/debug_info.h"
	#include "daScript/ast/compilation_errors.h"

	#ifdef _MSC_VER
	#pragma warning(disable:4262)
	#pragma warning(disable:4127)
	#pragma warning(disable:4702)
	#endif
    
    using namespace das;
    
    void das_yyerror (const string & error, das::CompilationError cerr = das::CompilationError::syntax_error);
    void das_yyerror (const string & error, const das::LineInfo & at, das::CompilationError cerr = das::CompilationError::unspecified);
	void das_checkName(const string & name, const LineInfo &at);
    int yylex();
    void yybegin(const char * str);
%}

%locations
%verbose
%debug

%union {
    char                            ch;
    bool                            b;
    int32_t                         i;
    uint32_t                        ui;
    int64_t                         i64;
    uint64_t                        ui64;
    double                          d;
	double                          fd;
    string *                        s;
    vector<string> *                pNameList;
    VariableDeclaration *           pVarDecl;
    vector<VariableDeclaration*> *  pVarDeclList;
    TypeDecl *                      pTypeDecl;
    Expression *                    pExpression;
    Type                            type;
    AnnotationArgument *            aa;
    AnnotationArgumentList *        aaList;
    AnnotationDeclaration *         fa;
    AnnotationList *                faList;
    MakeStruct *                    pMakeStruct;
    Enumeration *                   pEnum;
    Structure *                     pStructure;
}

%destructor { delete $$; } <s>
%destructor { delete $$; } <pNameList>
%destructor { delete $$; } <pVarDecl>
%destructor { deleteVariableDeclarationList($$); } <pVarDeclList>
%destructor { delete $$; } <pTypeDecl>
%destructor { delete $$; } <pExpression>
%destructor { delete $$; } <aa>
%destructor { delete $$; } <aaList>
%destructor { delete $$; } <fa>
%destructor { delete $$; } <faList>
%destructor { delete $$; } <pMakeStruct>
%destructor { delete $$; } <pEnum>

%token  LEXER_ERROR

/* keywords */
%token  DAS_STRUCT     DAS_LET        DAS_DEF        DAS_WHILE
%token  DAS_IF         DAS_ELSE       DAS_FOR        DAS_CATCH
%token  DAS_TRUE       DAS_FALSE      DAS_NEWT       DAS_TYPEINFO
%token  DAS_TYPE       DAS_IN         DAS_ELIF       DAS_ARRAY
%token  DAS_RETURN     DAS_NULL       DAS_BREAK      DAS_TRY
%token  DAS_OPTIONS    DAS_TABLE      DAS_EXPECT     DAS_CONST
%token  DAS_REQUIRE    DAS_OPERATOR   DAS_ENUM       DAS_FINALLY
%token  DAS_DELETE     DAS_DEREF      DAS_SCOPE      DAS_TYPEDEF
%token  DAS_WITH       DAS_CAST       DAS_OVERRIDE   DAS_UPCAST
%token  DAS_ITERATOR   DAS_VAR		  DAS_ADDR       DAS_CONTINUE
%token  DAS_WHERE      DAS_REINTERPRET

/* basic types */
%token  DAS_TBOOL       DAS_TVOID       DAS_TSTRING     DAS_TAUTO
%token  DAS_TINT        DAS_TINT2       DAS_TINT3       DAS_TINT4
%token  DAS_TUINT       DAS_TUINT2      DAS_TUINT3      DAS_TUINT4
%token  DAS_TFLOAT      DAS_TFLOAT2     DAS_TFLOAT3     DAS_TFLOAT4
%token  DAS_TRANGE      DAS_TURANGE     DAS_TBLOCK      DAS_TINT64
%token  DAS_TUINT64     DAS_TDOUBLE	    DAS_TFUNCTION   DAS_TLAMBDA
%token  DAS_TINT8       DAS_TUINT8      DAS_TINT16      DAS_TUINT16
%token  DAS_TTUPLE

/* operators */
%token  ADDEQU      SUBEQU      DIVEQU      MULEQU      MODEQU
%token  ANDEQU      OREQU       XOREQU      SHL         SHR
%token  ADDADD      SUBSUB      LEEQU       SHLEQU      SHREQU
%token  GREQU       EQUEQU      NOTEQU      RARROW      LARROW
%token  QQ          QDOT        LPIPE       LBPIPE      RPIPE
%token  CLONEEQU    ROTL        ROTR        ROTLEQU     ROTREQU
%token  MAPTO

%token	BRABRAB		/* [[ */
%token	BRACBRB		/* [{ */
%token	CBRCBRB		/* {{ */

%token<i>       INTEGER
%token<i64>     LONG_INTEGER
%token<ui>      UNSIGNED_INTEGER
%token<ui64>    UNSIGNED_LONG_INTEGER
%token<fd>      FLOAT
%token<d>       DOUBLE
%token<s>       NAME

%token      BEGIN_STRING
%token<ch>  STRING_CHARACTER
%token      END_STRING
%token		BEGIN_STRING_EXPR
%token		END_STRING_EXPR

%type <pNameList>       variable_name_list
%type <type>            basic_type_declaration
%type <pTypeDecl>       type_declaration
%type <pTypeDecl>       auto_type_declaration
%type <pTypeDecl>       optional_function_type
%type <pTypeDecl>       structure_type_declaration
%type <pVarDeclList>    struct_variable_declaration_list
%type <pVarDeclList>    global_variable_declaration_list
%type <pVarDeclList>    optional_function_argument_list
%type <pVarDeclList>    function_argument_list
%type <pVarDecl>        variable_declaration
%type <pVarDecl>        function_argument_declaration
%type <pVarDecl>        structure_variable_declaration
%type <pVarDecl>        let_variable_declaration
%type <pVarDecl>        tuple_type
%type <pVarDeclList>    tuple_type_list
%type <s>               name_in_namespace
%type <s>               annotation_declaration_name
%type <s>               function_name
%type <s>               optional_structure_parent
%type <s>               require_module_name
%type <aa>              annotation_argument
%type <aaList>          annotation_argument_list
%type <aaList>          optional_field_annotation
%type <fa>              annotation_declaration
%type <faList>          annotation_list
%type <faList>          optional_annotation_list
%type <pStructure>      structure_name

%type <b>               copy_or_move
%type <b>               let_scope
%type <b>               optional_override
%type <b>               kwd_let

%type <i>               copy_or_move_or_clone

%type <pEnum>           enum_list

%type <pExpression>     expr
%type <pExpression>     expr_assign
%type <pExpression>     expr_list
%type <pExpression>     expression_let
%type <pExpression>     expressions
%type <pExpression>     expression_block
%type <pExpression>     expression_with
%type <pExpression>     expression_while_loop
%type <pExpression>     expression_for_loop
%type <pExpression>     expression_break
%type <pExpression>     expression_continue
%type <pExpression>     expression_delete
%type <pExpression>     expression_return
%type <pExpression>     expression_else
%type <pExpression>     expression_if_then_else
%type <pExpression>     expression_try_catch
%type <pExpression>     expr_new
%type <pExpression>     expr_pipe
%type <pExpression>     expr_type_info
%type <pExpression>     expr_cast
%type <pExpression>     expr_block
%type <pExpression>     expr_named_call
%type <pExpression>     expression_any
%type <pExpression>     expr_numeric_const
%type <pExpression>     string_builder_body
%type <pExpression>     string_builder
%type <pExpression>     make_decl
%type <pMakeStruct>     make_struct_fields
%type <pExpression>     make_struct_decl
%type <pExpression>     make_struct_dim
%type <pExpression>     make_tuple
%type <pExpression>     make_map_tuple
%type <pExpression>     make_any_tuple
%type <pExpression>     make_dim
%type <pExpression>     make_dim_decl
%type <pExpression>     make_table
%type <pExpression>     make_table_decl
%type <pExpression>     array_comprehension_where
%type <pExpression>     array_comprehension
%type <pExpression>     expr_method_call

%type <s>               character_sequence
%type <s>               string_constant

/* operation precedence*/
%left       ','
%right      '=' ADDEQU SUBEQU DIVEQU MULEQU MODEQU ANDEQU OREQU XOREQU LARROW SHLEQU SHREQU ROTLEQU ROTREQU
%right      '?' ':'
%left       '|'
%left       '^'
%left       '&'
%left       EQUEQU NOTEQU
%left       '<' '>' LEEQU GREQU
%left       SHL SHR ROTL ROTR
%left       '-' '+'
%left       '*' '/' '%'
%left       QQ
%right      '@' UNARY_MINUS UNARY_PLUS '~' '!' PRE_INC PRE_DEC ADDADD SUBSUB
%left       LPIPE RPIPE LBPIPE
%left       POST_INC POST_DEC '.' '[' ']' '(' ')' RARROW QDOT
%nonassoc   COLCOL

%%

program
    :
    |   program structure_declaration
    |   program enum_declaration
    |   program global_let
    |   program function_declaration
    |   program expect_declaration
    |   program require_declaration
	|	program options_declaration
    |   program alias_declaration
    ;

character_sequence
    :   STRING_CHARACTER[char]                              { $$ = new string(); *$$ += $char; }
    |   character_sequence[elem]  STRING_CHARACTER[char]    { $$ = $elem; *$elem += $char; }
    ;

string_constant
    :   BEGIN_STRING character_sequence[seq] END_STRING    { $$ = $seq; }
    ;

string_builder_body
    :   {
        $$ = new ExprStringBuilder();
    }
    |   string_builder_body[sb] character_sequence[sconst] {
        bool err;
        auto esconst = unescapeString(*$sconst,&err);
        if ( err ) das_yyerror("invalid escape sequence",tokAt(@sb), CompilationError::invalid_escape_sequence);
        auto sc = make_shared<ExprConstString>(tokAt(@sconst),esconst);
        delete $sconst;
        static_cast<ExprStringBuilder *>($sb)->elements.push_back(sc);
        $$ = $sb;
    }
    |   string_builder_body[sb] BEGIN_STRING_EXPR expr[subexpr] END_STRING_EXPR {
        auto se = ExpressionPtr($subexpr);
        static_cast<ExprStringBuilder *>($sb)->elements.push_back(se);
        $$ = $sb;
    }
    ;

string_builder
    :   BEGIN_STRING string_builder_body[sb] END_STRING {
        auto strb = static_cast<ExprStringBuilder *>($sb);
        if ( strb->elements.size()==0 ) {
            $$ = new ExprConstString(strb->at,"");
            delete $sb;
        } else if ( strb->elements.size()==1 && strb->elements[0]->rtti_isStringConstant() ) {
            auto sconst = static_pointer_cast<ExprConstString>(strb->elements[0]);
            $$ = new ExprConstString(strb->at,sconst->text);
            delete $sb;
        } else {
            $$ = $sb;
        }
    }
    ;

options_declaration
	:	DAS_OPTIONS	annotation_argument_list[list] {
		if ( g_Program->options.size() ) {
			g_Program->options.insert ( g_Program->options.begin(),
                $list->begin(), $list->end() );
		} else {
			swap ( g_Program->options, *$list );
		}
		auto opt = g_Program->options.find("indenting", tInt);
		extern int das_tab_size, das_def_tab_size;
		if (opt)
		{
			if (opt->iValue != 0 && opt->iValue != 2 && opt->iValue != 4 && opt->iValue != 8)//this is error
				das_tab_size = das_def_tab_size;
			else
				das_tab_size = opt->iValue ? opt->iValue : das_def_tab_size;//0 is default
		}
		delete $list;
	}
	;

require_declaration
    :   DAS_REQUIRE require_list
    ;

require_list
    :   require_module
    |   require_list ',' require_module
    ;

require_module_name
    :   NAME[name] {
        $$ = $name;
    }
    |   require_module_name[req] '.' NAME[name] {
        *$req += ".";
        *$req += *$name;
        delete $name;
        $$ = $req;
    }
    ;

require_module
    :   require_module_name[name] {
        auto modN = getModuleName(*$name);
        if ( !g_Program->addModule(modN) ) {
            das_yyerror("required module not found " + *$name,tokAt(@name),
                CompilationError::module_not_found);
        }
        delete $name;
    }
    ;

expect_declaration
    :   DAS_EXPECT expect_list
    ;

expect_list
    :   expect_error
    |   expect_list ',' expect_error
    ;

expect_error
    : INTEGER[err] {
        g_Program->expectErrors[CompilationError($err)] ++;
    }
    | INTEGER[err] ':' INTEGER[count] {
        g_Program->expectErrors[CompilationError($err)] += $count;
    }
    ;

expression_else
    :                                                      { $$ = nullptr; }
    |   DAS_ELSE expression_block[block]                   { $$ = $block; }
    |   DAS_ELIF[loc] expr[cond] expression_block[block] expression_else[then] {
        $$ = new ExprIfThenElse(tokAt(@loc),ExpressionPtr($cond),
            ExpressionPtr($block),ExpressionPtr($then));
    }
    ;

expression_if_then_else
    :   DAS_IF[loc] expr[cond] expression_block[block] expression_else[then] {
        $$ = new ExprIfThenElse(tokAt(@loc),ExpressionPtr($cond),
            ExpressionPtr($block),ExpressionPtr($then));
    }
    ;

expression_for_loop
    :   DAS_FOR[loc] variable_name_list[iters] DAS_IN expr_list[srcs] ';' expression_block[block] {
        auto pFor = new ExprFor(tokAt(@loc));
        pFor->iterators = *$iters;
        delete $iters;
        pFor->sources = sequenceToList($srcs);
        pFor->subexpr = ExpressionPtr($block);
        ((ExprBlock *)$block)->inTheLoop = true;
        $$ = pFor;
    }
    ;

expression_while_loop
    :   DAS_WHILE[loc] expr[condition] expression_block[block] {
        auto pWhile = new ExprWhile(tokAt(@loc));
        pWhile->cond = ExpressionPtr($condition);
        pWhile->body = ExpressionPtr($block);
        ((ExprBlock *)$block)->inTheLoop = true;
        $$ = pWhile;
    }
    ;

expression_with
    :   DAS_WITH[loc] expr[with] expression_block[block] {
        auto pWith = new ExprWith(tokAt(@loc));
        pWith->with = ExpressionPtr($with);
        pWith->body = ExpressionPtr($block);
        $$ = pWith;
    }
    ;

annotation_argument
    :   NAME[name] '=' string_constant[value]   { $$ = new AnnotationArgument(*$name,*$value); delete $value; delete $name; }
    |   NAME[name] '=' NAME[value]              { $$ = new AnnotationArgument(*$name,*$value); delete $value; delete $name; }
    |   NAME[name] '=' INTEGER[value]           { $$ = new AnnotationArgument(*$name,$value); delete $name; }
    |   NAME[name] '=' FLOAT[value]             { $$ = new AnnotationArgument(*$name,float($value)); delete $name; }
    |   NAME[name] '=' DAS_TRUE                 { $$ = new AnnotationArgument(*$name,true); delete $name; }
    |   NAME[name] '=' DAS_FALSE                { $$ = new AnnotationArgument(*$name,false); delete $name; }
    ;

annotation_argument_list
    :   annotation_argument[arg]  {
        $$ = new AnnotationArgumentList();
        $$->push_back(*$arg);
        delete $arg;
    }
    |   annotation_argument_list[argL] ',' annotation_argument[arg] {
            $$ = $argL;
            $$->push_back(*$arg);
            delete $arg;
    }
    ;

annotation_declaration_name
    :   name_in_namespace[name]     { $$ = $name; }
    |   DAS_REQUIRE                 { $$ = new string("require"); }
    ;

annotation_declaration
    :   annotation_declaration_name[name] {
        $$ = new AnnotationDeclaration();
        if ( auto ann = findAnnotation(*$name,tokAt(@name)) ) {
            $$->annotation = ann->shared_from_this();
        }
        delete $name;
    }
    |   annotation_declaration_name[name] '(' annotation_argument_list[argL] ')' {
        $$ = new AnnotationDeclaration();
        if ( auto ann = findAnnotation(*$name,tokAt(@name)) ) {
            $$->annotation = ann->shared_from_this();
        }
        swap ( $$->arguments, *$argL );
        delete $argL;
        delete $name;
    }
    ;

annotation_list
    :   annotation_declaration[ann] {
            $$ = new AnnotationList();
            $$->push_back(AnnotationDeclarationPtr($ann));
    }
    |   annotation_list[annL] ',' annotation_declaration[ann] {
        $$ = $annL;
        $$->push_back(AnnotationDeclarationPtr($ann));
    }
    ;

optional_annotation_list
    :                                   { $$ = nullptr; }
    |   '[' annotation_list[annL] ']'   { $$ = $annL; }
    ;

optional_function_argument_list
    :                                           { $$ = nullptr; }
    |   '(' ')'                                 { $$ = nullptr; }
    |   '(' function_argument_list[list] ')'    { $$ = $list; }
    ;

optional_function_type
    :   {
        $$ = new TypeDecl(Type::autoinfer);
        $$->at = LineInfo(g_FileAccessStack.back(), yylloc.first_column,yylloc.first_line);
    }
    |   ':' type_declaration[typeDecl]  {
        $$ = $typeDecl;
        $$->at = tokAt(@typeDecl);
    }
    ;

function_name
    :   NAME[name]        { 
		das_checkName(*$name,tokAt(@name));
		$$ = $name; 
	}
    |   DAS_OPERATOR '!'     { $$ = new string("!"); }
    |   DAS_OPERATOR '~'     { $$ = new string("~"); }
    |   DAS_OPERATOR ADDEQU  { $$ = new string("+="); }
    |   DAS_OPERATOR SUBEQU  { $$ = new string("-="); }
    |   DAS_OPERATOR MULEQU  { $$ = new string("*="); }
    |   DAS_OPERATOR DIVEQU  { $$ = new string("/="); }
    |   DAS_OPERATOR MODEQU  { $$ = new string("%="); }
    |   DAS_OPERATOR ANDEQU  { $$ = new string("&="); }
    |   DAS_OPERATOR OREQU   { $$ = new string("|="); }
    |   DAS_OPERATOR XOREQU  { $$ = new string("^="); }
    |   DAS_OPERATOR '+'     { $$ = new string("+"); }
    |   DAS_OPERATOR '-'     { $$ = new string("-"); }
    |   DAS_OPERATOR '*'     { $$ = new string("*"); }
    |   DAS_OPERATOR '/'     { $$ = new string("/"); }
    |   DAS_OPERATOR '%'     { $$ = new string("%"); }
    |   DAS_OPERATOR '<'     { $$ = new string("<"); }
    |   DAS_OPERATOR '>'     { $$ = new string(">"); }
    |   DAS_OPERATOR EQUEQU  { $$ = new string("=="); }
    |   DAS_OPERATOR NOTEQU  { $$ = new string("!="); }
    |   DAS_OPERATOR LEEQU   { $$ = new string("<="); }
    |   DAS_OPERATOR GREQU   { $$ = new string(">="); }
    |   DAS_OPERATOR '&'     { $$ = new string("&"); }
    |   DAS_OPERATOR '|'     { $$ = new string("|"); }
    |   DAS_OPERATOR '^'     { $$ = new string("^"); }
    |   ADDADD DAS_OPERATOR  { $$ = new string("++"); }
    |   SUBSUB DAS_OPERATOR  { $$ = new string("--"); }
    |   DAS_OPERATOR ADDADD  { $$ = new string("+++"); }
    |   DAS_OPERATOR SUBSUB  { $$ = new string("---"); }
    |   DAS_OPERATOR SHL     { $$ = new string("<<"); }
    |   DAS_OPERATOR SHR     { $$ = new string(">>"); }
    |   DAS_OPERATOR SHLEQU  { $$ = new string("<<="); }
    |   DAS_OPERATOR SHREQU  { $$ = new string(">>="); }
    |   DAS_OPERATOR ROTL    { $$ = new string("<<<"); }
    |   DAS_OPERATOR ROTR    { $$ = new string(">>>"); }
    |   DAS_OPERATOR ROTLEQU { $$ = new string("<<<="); }
    |   DAS_OPERATOR ROTREQU { $$ = new string(">>>="); }
    ;

function_declaration
    :   optional_annotation_list[annL] DAS_DEF[loc] function_name[name]
            optional_function_argument_list[list] optional_function_type[result] expression_block[block] {
        auto pFunction = make_shared<Function>();
        pFunction->at = tokAt(@loc);
        pFunction->name = *$name;
        pFunction->body = ExpressionPtr($block);
        pFunction->result = TypeDeclPtr($result);
        if ( $list ) {
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl ) {
                    for ( const auto & name : *pDecl->pNameList ) {
                        if ( !pFunction->findArgument(name) ) {
                            VariablePtr pVar = make_shared<Variable>();
                            pVar->name = name;
                            pVar->at = pDecl->at;
                            pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            if ( pDecl->pInit ) {
                                pVar->init = ExpressionPtr(pDecl->pInit->clone());
                                pVar->init_via_move = pDecl->init_via_move;
                                pVar->init_via_clone = pDecl->init_via_clone;
                            }
                            pFunction->arguments.push_back(pVar);
                        } else {
                            das_yyerror("function argument is already declared " + name,pDecl->at,
                                CompilationError::argument_already_declared);
                        }
                    }
                }
            }
            deleteVariableDeclarationList($list);
        }
        if ( $annL ) {
            for ( auto pA : *$annL ) {
                if ( pA->annotation ) {
                    if ( pA->annotation->rtti_isFunctionAnnotation() ) {
                        auto ann = static_pointer_cast<FunctionAnnotation>(pA->annotation);
                        string err;
                        if ( !ann->apply(pFunction, *g_Program->thisModuleGroup, pA->arguments, err) ) {
                            das_yyerror("can't apply annotation\n" + err,
                                tokAt(@loc), CompilationError::invalid_annotation);
                        }
                    } else {
                        das_yyerror("functions are only allowed function annotations",
                            tokAt(@loc), CompilationError::invalid_annotation);
                    }
                }
            }
            swap ( pFunction->annotations, *$annL );
            delete $annL;
        }
        if ( pFunction->isGeneric() ) {
            if ( !g_Program->addGeneric(pFunction) ) {
                das_yyerror("generic function is already defined " +
                    pFunction->getMangledName(),tokAt(@loc),
                        CompilationError::function_already_declared);
                pFunction.reset();
            }
        } else {
            if ( !g_Program->addFunction(pFunction) ) {
                das_yyerror("function is already defined " +
                    pFunction->getMangledName(),tokAt(@loc),
                        CompilationError::function_already_declared);
                pFunction.reset();
            }
        }
        delete $name;
    }
    ;

expression_block
    :   '{' expressions[block] '}' {
        $$ = $block;
    }
    |   '{' expressions[block] '}' DAS_FINALLY '{' expressions[final] '}' {
        auto pB = (ExprBlock *) $block;
        auto pF = (ExprBlock *) $final;
        swap ( pB->finalList, pF->list );
        $$ = $block;
        delete $final;
    }
    ;

expression_any
    :   ';'                                 { $$ = nullptr; }
    |   expr_pipe[subexpr]                  { $$ = $subexpr; }
    |   expr_assign[subexpr] ';'            { $$ = $subexpr; }
    |   expression_delete[subexpr] ';'      { $$ = $subexpr; }
    |   expression_let[subexpr]             { $$ = $subexpr; }
    |   expression_while_loop[subexpr]      { $$ = $subexpr; }
    |   expression_with[subexpr]            { $$ = $subexpr; }
    |   expression_for_loop[subexpr]        { $$ = $subexpr; }
    |   expression_break[subexpr] ';'       { $$ = $subexpr; }
    |   expression_continue[subexpr] ';'    { $$ = $subexpr; }
    |   expression_return[subexpr] ';'      { $$ = $subexpr; }
    |   expression_if_then_else[subexpr]    { $$ = $subexpr; }
    |   expression_try_catch[subexpr]       { $$ = $subexpr; }
    ;

expressions
    :   {
        $$ = new ExprBlock();
    }
    |   expressions[block] expression_any[subexpr]      {
        $$ = $block;
        if ( $subexpr ) {
			if ( !$block->at.line ) {
				$block->at = $subexpr->at;
			}
            static_cast<ExprBlock*>($block)->list.push_back(ExpressionPtr($subexpr));
        }
    }
    |   expressions[block] error {
        delete $block; $$ = nullptr; YYABORT;
    }
    ;

expr_pipe
    :   expr_assign[fncall] LBPIPE[loc] expr_block[arg] {
        Expression * pipeCall = $fncall->tail();
        if ( pipeCall->rtti_isCallLikeExpr() ) {
            auto pCall = (ExprLooksLikeCall *) pipeCall;
            pCall->arguments.push_back(ExpressionPtr($arg));
            $$ = $fncall;
        } else {
            das_yyerror("can only pipe into function call",tokAt(@loc),CompilationError::cant_pipe);
            $$ = $fncall;
        }
    }
    ;

name_in_namespace
    :   NAME[name]                             { $$ = $name; }
    |   NAME[namespace] COLCOL NAME[name]      {
            *$namespace += "::";
            *$namespace += *$name;
            delete $name;
            $$ = $namespace;
        }
    |   COLCOL NAME[name]                      { *$name = "::" + *$name; $$ = $name; }
    ;

expression_delete
    :   DAS_DELETE[loc] expr[subexpr] {
        $$ = new ExprDelete(tokAt(@loc), ExpressionPtr($subexpr));
    }
    ;

expr_new
    :   DAS_NEWT[loc] type_declaration[typeDecl]   {
        $$ = new ExprNew(tokAt(@loc),TypeDeclPtr($typeDecl),false);
    }
    |   DAS_NEWT[loc] type_declaration[typeDecl] '(' ')'   {
        $$ = new ExprNew(tokAt(@loc),TypeDeclPtr($typeDecl),true);
    }
    |   DAS_NEWT[loc] type_declaration[typeDecl] '(' expr_list[arguments] ')'   {
        auto pNew = new ExprNew(tokAt(@loc),TypeDeclPtr($typeDecl),true);
        $$ = parseFunctionArguments(pNew,$arguments);
    }
    |   DAS_NEWT[loc] make_decl[md] {
        $$ = new ExprAscend(tokAt(@loc),ExpressionPtr($md));
    }
    ;

expression_break
    :   DAS_BREAK[loc] { $$ = new ExprBreak(tokAt(@loc)); }
    ;

expression_continue
    :   DAS_CONTINUE[loc] { $$ = new ExprContinue(tokAt(@loc)); }
    ;

expression_return
    :   DAS_RETURN[loc] {
        $$ = new ExprReturn(tokAt(@loc),nullptr);
    }
    |   DAS_RETURN[loc] expr[subexpr] {
        $$ = new ExprReturn(tokAt(@loc),ExpressionPtr($subexpr));
    }
    |   DAS_RETURN[loc] LARROW expr[subexpr] {
        auto pRet = new ExprReturn(tokAt(@loc),ExpressionPtr($subexpr));
        pRet->moveSemantics = true;
        $$ = pRet;
    }
    ;

expression_try_catch
    :   DAS_TRY[loc] expression_block[tryBlock] DAS_CATCH expression_block[catchBlock] {
        $$ = new ExprTryCatch(tokAt(@loc),ExpressionPtr($tryBlock),ExpressionPtr($catchBlock));
    }
    ;

let_scope
    :               { $$ = false; }
    |   DAS_IN DAS_SCOPE  { $$ = true; }
    ;

kwd_let
    :   DAS_LET  { $$ = true; }
    |   DAS_VAR  { $$ = false; }
    ;

expression_let
    :   kwd_let let_scope[inScope] let_variable_declaration[decl] {
        auto pLet = new ExprLet();
        pLet->inScope = $inScope;
        if ( $decl->pTypeDecl ) {
            for ( const auto & name : *$decl->pNameList ) {
                if ( !pLet->find(name) ) {
                    VariablePtr pVar = make_shared<Variable>();
                    pVar->name = name;
                    pVar->at = $decl->at;
                    pVar->type = make_shared<TypeDecl>(*$decl->pTypeDecl);
                    if ( $decl->pInit ) {
                        pVar->init = $decl->pInit->clone();
                        pVar->init_via_move = $decl->init_via_move;
                        pVar->init_via_clone = $decl->init_via_clone;
                    }
                    if ( $kwd_let ) {
                        pVar->type->constant = true;
                    } else {
                        pVar->type->removeConstant = true;
                    }
                    pLet->variables.push_back(pVar);
                } else {
                    das_yyerror("local variable is already declared " + name,tokAt(@kwd_let),
                        CompilationError::local_variable_already_declared);
                }
            }
        }
        delete $decl;
        $$ = pLet;
    }
    ;

expr_cast
    :   DAS_CAST[loc] '<' type_declaration[decl] '>' expr[subexpr] {
        $$ = new ExprCast(tokAt(@loc),ExpressionPtr($subexpr),TypeDeclPtr($decl));
    }
    |   DAS_UPCAST[loc] '<' type_declaration[decl] '>' expr[subexpr] {
        auto pCast = new ExprCast(tokAt(@loc),ExpressionPtr($subexpr),TypeDeclPtr($decl));
        pCast->upcast = true;
        $$ = pCast;
    }
    |   DAS_REINTERPRET[loc] '<' type_declaration[decl] '>' expr[subexpr] {
        auto pCast = new ExprCast(tokAt(@loc),ExpressionPtr($subexpr),TypeDeclPtr($decl));
        pCast->reinterpret = true;
        $$ = pCast;
    }
    ;

expr_type_info
    :   DAS_TYPEINFO[loc] '(' NAME[trait] expr[subexpr] ')' {
            $$ = new ExprTypeInfo(tokAt(@loc),*$trait,ExpressionPtr($subexpr));
            delete $trait;
    }
    |   DAS_TYPEINFO[loc] '(' NAME[trait] '<' NAME[subtrait] '>' expr[subexpr] ')' {
            $$ = new ExprTypeInfo(tokAt(@loc),*$trait,ExpressionPtr($subexpr),*$subtrait);
            delete $trait;
            delete $subtrait;
    }
    |   DAS_TYPEINFO[loc] '(' NAME[trait] DAS_TYPE type_declaration[decl] ')' {
            $$ = new ExprTypeInfo(tokAt(@loc),*$trait,TypeDeclPtr($decl));
            delete $trait;
    }
    |   DAS_TYPEINFO[loc] '(' NAME[trait] '<' NAME[subtrait] '>'DAS_TYPE type_declaration[decl] ')' {
            $$ = new ExprTypeInfo(tokAt(@loc),*$trait,TypeDeclPtr($decl),*$subtrait);
            delete $trait;
            delete $subtrait;
    }
    ;

expr_list
    :   expr[subexpr] {
        $$ = $subexpr;
    }
    |   expr_list[left] ',' expr[right]     {
            $$ = new ExprSequence(tokAt(@left),ExpressionPtr($left),ExpressionPtr($right));
    }
    ;

expr_block
    :   expression_block[block]             {
        ExprBlock * closure = (ExprBlock *) $block;
        $$ = new ExprMakeBlock(tokAt(@block),ExpressionPtr($block));
        closure->returnType = make_shared<TypeDecl>(Type::autoinfer);
    }
    |   '$' optional_annotation_list[annL] optional_function_argument_list[list]
                                optional_function_type[result] expression_block[block] {
        $$ = new ExprMakeBlock(tokAt(@block),ExpressionPtr($block));
        ExprBlock * closure = (ExprBlock *) $block;
        closure->returnType = TypeDeclPtr($result);
        if ( $list ) {
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl ) {
                    for ( const auto & name : *pDecl->pNameList ) {
                        if ( !closure->findArgument(name) ) {
                            VariablePtr pVar = make_shared<Variable>();
                            pVar->name = name;
                            pVar->at = pDecl->at;
                            pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            if ( pDecl->pInit ) {
                                pVar->init = ExpressionPtr(pDecl->pInit->clone());
                                pVar->init_via_move = pDecl->init_via_move;
                                pVar->init_via_clone = pDecl->init_via_clone;
                            }
                            closure->arguments.push_back(pVar);
                        } else {
                            das_yyerror("block argument is already declared " + name,
                                pDecl->at,CompilationError::argument_already_declared);
                        }
                    }
                }
            }
            deleteVariableDeclarationList($list);
        }
        if ( $annL ) {
            for ( auto pA : *$annL ) {
                if ( pA->annotation ) {
                    if ( pA->annotation->rtti_isFunctionAnnotation() ) {
                        auto ann = static_pointer_cast<FunctionAnnotation>(pA->annotation);
                        string err;
                        if ( !ann->apply(closure, *g_Program->thisModuleGroup, pA->arguments, err) ) {
                            das_yyerror("can't apply annotation\n" + err, tokAt(@annL),
                                CompilationError::invalid_annotation);
                        }
                    } else {
                        das_yyerror("blocks are only allowed function annotations", tokAt(@annL),
                            CompilationError::invalid_annotation);
                    }
                }
            }
            swap ( closure->annotations, *$annL );
            delete $annL;
        }
    }
    ;

expr_numeric_const
    :   INTEGER[const]                        { $$ = new ExprConstInt(tokAt(@const),(int32_t)$const); }
    |   UNSIGNED_INTEGER[const]               { $$ = new ExprConstUInt(tokAt(@const),(uint32_t)$const); }
    |   LONG_INTEGER[const]                   { $$ = new ExprConstInt64(tokAt(@const),(int64_t)$const); }
    |   UNSIGNED_LONG_INTEGER[const]          { $$ = new ExprConstUInt64(tokAt(@const),(uint64_t)$const); }
    |   FLOAT[const]                          { $$ = new ExprConstFloat(tokAt(@const),(float)$const); }
	|   DOUBLE[const]                         { $$ = new ExprConstDouble(tokAt(@const),(double)$const); }
    ;

expr_assign
    :   expr[ex]                             { $$ = $ex; }
    |   expr[left] '='[loc]    expr[right]   { $$ = new ExprCopy(tokAt(@loc),ExpressionPtr($left),ExpressionPtr($right)); }
    |   expr[left] LARROW[loc] expr[right]   { $$ = new ExprMove(tokAt(@loc),ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] CLONEEQU[loc] expr[right] { $$ = new ExprClone(tokAt(@loc),ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] ANDEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"&=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] OREQU[loc] expr[right]    { $$ = new ExprOp2(tokAt(@loc),"|=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] XOREQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"^=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] ADDEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"+=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] SUBEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"-=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] MULEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"*=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] DIVEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"/=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] MODEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"%=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] SHLEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"<<=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] SHREQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),">>=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] ROTLEQU[loc] expr[right]  { $$ = new ExprOp2(tokAt(@loc),"<<<=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] ROTREQU[loc] expr[right]  { $$ = new ExprOp2(tokAt(@loc),">>>=", ExpressionPtr($left), ExpressionPtr($right)); }
    ;

expr_named_call
    :   name_in_namespace[name] '(' '[' make_struct_fields[list] ']' ')' {
        auto nc = new ExprNamedCall(tokAt(@name),*$name);
        nc->arguments = *$list;
        delete $list;
        delete $name;
        $$ = nc;
    }
    ;

/* a->b(args) is short for invoke(a.b, a, args)  */
expr_method_call
    :   expr[left] RARROW[loc] NAME[method_name] '(' ')' {
        auto pInvoke = makeInvokeMethod(tokAt(@loc), $left, *$method_name);
        delete $method_name;
        $$ = pInvoke;
    }
    |   expr[left] RARROW[loc] NAME[method_name] '(' expr_list[arguments] ')' {
        auto pInvoke = makeInvokeMethod(tokAt(@loc), $left, *$method_name);
        auto callArgs = sequenceToList($arguments);
        pInvoke->arguments.insert ( pInvoke->arguments.end(), callArgs.begin(), callArgs.end() );
        delete $method_name;
        $$ = pInvoke;
    }
    ;

expr
    :   DAS_NULL[loc]                         { $$ = new ExprConstPtr(tokAt(@loc),nullptr); }
    |   name_in_namespace[name]               { $$ = new ExprVar(tokAt(@name),*$name); delete $name; }
    |   expr_numeric_const[nc]                { $$ = $nc; }
    |   string_builder[sb]                    { $$ = $sb; }
    |   make_decl[md]                         { $$ = $md; }
    |   DAS_TRUE[loc]                         { $$ = new ExprConstBool(tokAt(@loc),true); }
    |   DAS_FALSE[loc]                        { $$ = new ExprConstBool(tokAt(@loc),false); }
    |   '!'[loc] expr[subexpr]                { $$ = new ExprOp1(tokAt(@loc),"!",ExpressionPtr($subexpr)); }
    |   '~'[loc] expr[subexpr]                { $$ = new ExprOp1(tokAt(@loc),"~",ExpressionPtr($subexpr)); }
    |   '+'[loc] expr[subexpr] %prec  UNARY_PLUS  { $$ = new ExprOp1(tokAt(@loc),"+",ExpressionPtr($subexpr)); }
    |   '-'[loc] expr[subexpr] %prec  UNARY_MINUS { $$ = new ExprOp1(tokAt(@loc),"-",ExpressionPtr($subexpr)); }
    |   expr[left] SHL[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"<<", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] SHR[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),">>", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] ROTL[loc]    expr[right]  { $$ = new ExprOp2(tokAt(@loc),"<<<", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] ROTR[loc]    expr[right]  { $$ = new ExprOp2(tokAt(@loc),">>>", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '+'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"+", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '-'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"-", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '*'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"*", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '/'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"/", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '%'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"%", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '<'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"<", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '>'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),">", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] EQUEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"==", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] NOTEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"!=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] LEEQU[loc]  expr[right]   { $$ = new ExprOp2(tokAt(@loc),"<=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] GREQU[loc]  expr[right]   { $$ = new ExprOp2(tokAt(@loc),">=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '&'[loc] expr[right]      { $$ = new ExprOp2(tokAt(@loc),"&", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '|'[loc] expr[right]      { $$ = new ExprOp2(tokAt(@loc),"|", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '^'[loc] expr[right]      { $$ = new ExprOp2(tokAt(@loc),"^", ExpressionPtr($left), ExpressionPtr($right)); }
    |   ADDADD[loc] expr[subexpr] %prec PRE_INC  { $$ = new ExprOp1(tokAt(@loc),"++", ExpressionPtr($subexpr)); }
    |   SUBSUB[loc] expr[subexpr] %prec PRE_DEC  { $$ = new ExprOp1(tokAt(@loc),"--", ExpressionPtr($subexpr)); }
    |   expr[subexpr] ADDADD[loc] %prec POST_INC { $$ = new ExprOp1(tokAt(@loc),"+++", ExpressionPtr($subexpr)); }
    |   expr[subexpr] SUBSUB[loc] %prec POST_DEC { $$ = new ExprOp1(tokAt(@loc),"---", ExpressionPtr($subexpr)); }
    |   '(' expr[subexpr] ')'                    { $$ = $subexpr; }
    |   expr[subexpr] '['[loc] expr[index] ']'   { $$ = new ExprAt(tokAt(@loc), ExpressionPtr($subexpr), ExpressionPtr($index)); }
    |   expr[subexpr] '.'[loc] NAME[name]        { $$ = new ExprField(tokAt(@loc), ExpressionPtr($subexpr), *$name); delete $name; }
    |   expr[subexpr] QDOT[loc] NAME[name]       { $$ = new ExprSafeField(tokAt(@loc), ExpressionPtr($subexpr), *$name); delete $name; }
    |   '@'[loc] name_in_namespace[name]         { $$ = new ExprAddr(tokAt(@loc),*$name); delete $name; }
    |   name_in_namespace[name] '(' ')' {
            $$ = g_Program->makeCall(tokAt(@name),*$name);
            delete $name;
        }
    |   name_in_namespace[name] '(' expr_list[arguments] ')' {
            $$ = parseFunctionArguments(g_Program->makeCall(tokAt(@name),*$name),$arguments);
            delete $name;
        }
    |   basic_type_declaration[type] '(' ')' {
        $$ = g_Program->makeCall(tokAt(@type),das_to_string($type));
    }
    |   basic_type_declaration[type] '(' expr_list[arguments] ')' {
            $$ = parseFunctionArguments(g_Program->makeCall(tokAt(@type),das_to_string($type)),$arguments);
        }
    |   DAS_DEREF[loc] '(' expr[subexpr] ')'       { $$ = new ExprPtr2Ref(tokAt(@loc),ExpressionPtr($subexpr)); }
	|   DAS_ADDR[loc] '(' expr[subexpr] ')'       { $$ = new ExprRef2Ptr(tokAt(@loc),ExpressionPtr($subexpr)); }
    |   DAS_TLAMBDA[loc] '(' ')'                   { $$ = new ExprMakeLambda(tokAt(@loc)); }
    |   DAS_TLAMBDA[loc] '(' expr[subexpr] ')'     { $$ = new ExprMakeLambda(tokAt(@loc), ExpressionPtr($subexpr)); }
    |   expr[subexpr] QQ[loc] expr[dval]           { $$ = new ExprNullCoalescing(tokAt(@loc),ExpressionPtr($subexpr),ExpressionPtr($dval)); }
    |   expr[subexpr] '?'[loc] expr[left] ':' expr[right] {
            $$ = new ExprOp3(tokAt(@loc),"?",ExpressionPtr($subexpr),ExpressionPtr($left),ExpressionPtr($right));
        }
    |   expr_type_info[subexpr]                 { $$ = $subexpr; }
    |   expr_cast[subexpr]                      { $$ = $subexpr; }
    |   expr_new[subexpr]                       { $$ = $subexpr; }
    |   expr_method_call[subexpr]               { $$ = $subexpr; }
    |   expr_named_call[subexpr]                { $$ = $subexpr; }
    |   expr_block[subexpr]                     { $$ = $subexpr; }
    |   expr[fncall] LPIPE[loc] expr[arg] {
        if ( $fncall->rtti_isCallLikeExpr() ) {
            auto pCall = (ExprLooksLikeCall *) $fncall;
            pCall->arguments.push_back(ExpressionPtr($arg));
            $$ = $fncall;
        } else {
            das_yyerror("can only pipe into a function call",tokAt(@loc),CompilationError::cant_pipe);
            $$ = $fncall;
        }
    }
    |   expr[arg] RPIPE[loc] expr[fncall] {
        if ( $fncall->rtti_isCallLikeExpr() ) {
            auto pCall = (ExprLooksLikeCall *) $fncall;
            pCall->arguments.insert(pCall->arguments.begin(),ExpressionPtr($arg));
            $$ = $fncall;
        } else {
            das_yyerror("can only pipe into a function call",tokAt(@loc),CompilationError::cant_pipe);
            $$ = $fncall;
        }
    }
    | name_in_namespace[ena] NAME[eni] {
		ExprConstEnumeration * resEnum = nullptr;
        auto enums = g_Program->findEnum(*$ena);
        if ( enums.size()!=1 ) {
            if ( enums.size() ) {
                string candidates = g_Program->describeCandidates(enums);
                das_yyerror("enumeraiton not found " + *$ena + "\n" + candidates, tokAt(@ena),
                    CompilationError::enumeration_not_found);
            } else {
                das_yyerror("enumeraiton not found " + *$ena, tokAt(@ena),
                    CompilationError::enumeration_not_found);
            }
        } else {
            auto pEnum = enums.back();
            auto ff = pEnum->find(*$eni);
            if ( ff.second ) {
				auto td = make_shared<TypeDecl>(pEnum);
                resEnum = new ExprConstEnumeration(tokAt(@eni), ff.first, td);
            } else {
                das_yyerror("enumeraiton value not found " + *$ena + " " + *$eni, tokAt(@eni),
                    CompilationError::enumeration_not_found);
            }
        }
		if ( resEnum ) {
			$$ = resEnum;
		} else {
			$$ = new ExprConstInt(0);	// dummy
		}
        delete $ena;
        delete $eni;
    }
    ;

optional_field_annotation
    :                                           { $$ = nullptr; }
    |   '[' annotation_argument_list[alist] ']' { $$ = $alist; }
    ;

optional_override
    :               { $$ = false; }
    |   DAS_OVERRIDE   { $$ = true; }
    ;

structure_variable_declaration
    :   optional_field_annotation[alist] optional_override[ovr] variable_declaration[decl] {
        $decl->override = $ovr;
        $decl->annotation = $alist;
        $$ = $decl;
    }
    ;

struct_variable_declaration_list
    :   {
        $$ = new vector<VariableDeclaration*>();
    }
    |   struct_variable_declaration_list[list] structure_variable_declaration[decl] ';' {
        $$ = $list;
        $list->push_back($decl);
    }
    ;

function_argument_declaration
    :   variable_declaration[decl]          { $$ = $decl; $decl->pTypeDecl->constant = true; }
    |   DAS_VAR variable_declaration[decl]  { $$ = $decl; $decl->pTypeDecl->removeConstant = true; }
    ;

function_argument_list
    :   function_argument_declaration[decl]                                      { $$ = new vector<VariableDeclaration*>(); $$->push_back($decl); }
    |   function_argument_list[list] ';' function_argument_declaration[decl]     { $$ = $list; $list->push_back($decl); }
    ;

tuple_type
    :   type_declaration [typeDecl] {
        $$ = new VariableDeclaration(tokAt(@typeDecl),nullptr,$typeDecl,nullptr);
    }
    ;

tuple_type_list
    :   tuple_type[decl]                               { $$ = new vector<VariableDeclaration*>(); $$->push_back($decl); }
    |   tuple_type_list[list] ';' tuple_type[decl]     { $$ = $list; $list->push_back($decl); }
    ;

copy_or_move
    :   '='         { $$ = false; }
    |   LARROW      { $$ = true; }
    ;

variable_declaration        /* this one can have uninitialized variable which has no type */
    :   variable_name_list[list] {
        auto autoT = new TypeDecl(Type::autoinfer);
        $$ = new VariableDeclaration(tokAt(@list),$list,autoT,nullptr);
    }
    |   variable_name_list[list] ':' type_declaration[typeDecl]  {
        $$ = new VariableDeclaration(tokAt(@list),$list,$typeDecl,nullptr);
    }
    |   variable_name_list[list] ':' type_declaration[typeDecl] copy_or_move[com] expr[init] {
        $$ = new VariableDeclaration(tokAt(@list),$list,$typeDecl,$init);
        $$->init_via_move = $com;
    }
    |   variable_name_list[list] copy_or_move[com] expr[init] {
        auto typeDecl = new TypeDecl(Type::autoinfer);
        $$ = new VariableDeclaration(tokAt(@list),$list,typeDecl,$init);
        $$->init_via_move = $com;
    }
    |   variable_name_list[list] copy_or_move[com] expr_pipe[init] {
        auto typeDecl = new TypeDecl(Type::autoinfer);
        $$ = new VariableDeclaration(tokAt(@list),$list,typeDecl,$init);
        $$->init_via_move = $com;
    }
    ;

copy_or_move_or_clone
    :   '='         { $$ = CorM_COPY; }
    |   LARROW      { $$ = CorM_MOVE; }
    |   CLONEEQU    { $$ = CorM_CLONE; }
    ;

let_variable_declaration    /* let x; is prohibited. this one can't have uninitialized variable which has no type */
    :   variable_name_list[list] ':' type_declaration[typeDecl] ';' {
        $$ = new VariableDeclaration(tokAt(@list),$list,$typeDecl,nullptr);
    }
    |   variable_name_list[list] ':' type_declaration[typeDecl] copy_or_move_or_clone[com] expr[init] ';' {
        $$ = new VariableDeclaration(tokAt(@list),$list,$typeDecl,$init);
        $$->init_via_move  = ($com & CorM_MOVE) !=0;
        $$->init_via_clone = ($com & CorM_CLONE) !=0;
    }
    |   variable_name_list[list] ':' type_declaration[typeDecl] copy_or_move_or_clone[com] expr_pipe[init] {
        $$ = new VariableDeclaration(tokAt(@list),$list,$typeDecl,$init);
        $$->init_via_move  = ($com & CorM_MOVE) !=0;
        $$->init_via_clone = ($com & CorM_CLONE) !=0;
    }
    |   variable_name_list[list] copy_or_move_or_clone[com] expr[init] ';' {
        auto typeDecl = new TypeDecl(Type::autoinfer);
        $$ = new VariableDeclaration(tokAt(@list),$list,typeDecl,$init);
        $$->init_via_move  = ($com & CorM_MOVE) !=0;
        $$->init_via_clone = ($com & CorM_CLONE) !=0;
    }
    |   variable_name_list[list] copy_or_move_or_clone[com] expr_pipe[init] {
        auto typeDecl = new TypeDecl(Type::autoinfer);
        $$ = new VariableDeclaration(tokAt(@list),$list,typeDecl,$init);
        $$->init_via_move  = ($com & CorM_MOVE) !=0;
        $$->init_via_clone = ($com & CorM_CLONE) !=0;
    }
    ;

global_variable_declaration_list
    :   {
        $$ = new vector<VariableDeclaration*>();
    }
    |   global_variable_declaration_list[list] let_variable_declaration[decl] {
        $$ = $list;
        $list->push_back($decl);
    }
    ;

global_let
    :   kwd_let '{' global_variable_declaration_list[list] '}' {
        for ( auto pDecl : *$list ) {
            if ( pDecl->pTypeDecl ) {
                for ( const auto & name : *pDecl->pNameList ) {
                    VariablePtr pVar = make_shared<Variable>();
                    pVar->name = name;
                    pVar->at = pDecl->at;
                    pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                    if ( pDecl->pInit ) {
                        pVar->init = pDecl->pInit->clone();
                        pVar->init_via_move = pDecl->init_via_move;
                        pVar->init_via_clone = pDecl->init_via_clone;
                    }
                    if ( $kwd_let ) {
                        pVar->type->constant = true;
                    } else {
                        pVar->type->removeConstant = true;
                    }
                    if ( !g_Program->addVariable(pVar) )
                        das_yyerror("global variable is already declared " + name,pDecl->at,
                            CompilationError::global_variable_already_declared);
                }
            }
        }
        deleteVariableDeclarationList($list);
    }
    ;

enum_list
    :   {
        $$ = new Enumeration();
    }
    |   enum_list[pE] NAME[name] ';' {
		das_checkName(*$name,tokAt(@name));
        if ( !$pE->add(*$name) ) {
            das_yyerror("enumeration alread declared " + *$name, tokAt(@name),
                CompilationError::enumeration_value_already_declared);
        }
        delete $name;
        $$ = $pE;
    }
    |   enum_list[pE] NAME[name] '=' INTEGER[value] ';' {
		das_checkName(*$name,tokAt(@name));
        if ( !$pE->add(*$name,$value) ) {
            das_yyerror("enumeration value alread declared " + *$name, tokAt(@name),
                CompilationError::enumeration_value_already_declared);
        }
        delete $name;
        $$ = $pE;
    }
    ;

alias_declaration
    :   DAS_TYPEDEF[loc] NAME[name] '=' type_declaration[tdecl] {
		das_checkName(*$name,tokAt(@name));
        $tdecl->alias = *$name;
        if ( !g_Program->addAlias(TypeDeclPtr($tdecl)) ) {
            das_yyerror("type alias is already defined "+*$name,tokAt(@loc),
                CompilationError::type_alias_already_declared);
        }
        delete $name;
    }
    ;

enum_declaration
    :   DAS_ENUM[loc] NAME[name] '{' enum_list[pE] '}' {
		das_checkName(*$name,tokAt(@name));
        auto pEnum = EnumerationPtr($pE);
        pEnum->at = tokAt(@loc);
        pEnum->name = *$name; 
        if ( !g_Program->addEnumeration(pEnum) ) {
            das_yyerror("enumeration is already defined "+*$name,tokAt(@pE),
                CompilationError::enumeration_already_declared);
        }
		delete $name;
    }
    ;

optional_structure_parent
    :                                   { $$ = nullptr; }
    |   ':' name_in_namespace[name]     { $$ = $name; }
    ;

structure_name
    : NAME[name] optional_structure_parent[parent] {
		das_checkName(*$name,tokAt(@name));
        StructurePtr pStruct;
        if ( $parent ) {
            auto structs = g_Program->findStructure(*$parent);
            if ( structs.size()==1 ) {
                pStruct = structs.back()->clone();
                pStruct->name = *$name;
                pStruct->parent = structs.back().get();
                pStruct->annotations.clear();
            } else if ( structs.size()==0 ) {
                das_yyerror("parent structure not found"+*$parent,tokAt(@parent),
                    CompilationError::structure_not_found);
            } else {
                string candidates = g_Program->describeCandidates(structs);
                das_yyerror("too many options for "+*$parent + "\n" + candidates,tokAt(@parent),
                    CompilationError::structure_not_found);

            }
            delete $parent;
        } else {
            pStruct = make_shared<Structure>(*$name);
        }
        if ( pStruct ) {
            if ( !g_Program->addStructure(pStruct) ) {
                das_yyerror("structure is already defined "+*$name,tokAt(@name),
                    CompilationError::structure_already_declared);
                $$ = nullptr;
            } else {
                $$ = pStruct.get();
            }
        } else {
            $$ = nullptr;
        }
        delete $name;
    }
    ;

structure_declaration
    : optional_annotation_list[annL] DAS_STRUCT[loc] structure_name[ps] '{' struct_variable_declaration_list[list] '}' {
        if ( $ps ) {
            auto pStruct = $ps->shared_from_this();
            pStruct->at = tokAt(@loc);
            for ( auto pDecl : *$list ) {
                for ( const auto & name : *pDecl->pNameList ) {
                    auto oldFd = (Structure::FieldDeclaration *) pStruct->findField(name);
                    if ( !oldFd ) {
                        if ( pDecl->override ) {
                            das_yyerror("structure field is not overriding anything, "+name,pDecl->at,
                                CompilationError::invalid_override);
                        } else {
                            auto td = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            auto init = pDecl->pInit ? ExpressionPtr(pDecl->pInit->clone()) : nullptr;
                            pStruct->fields.emplace_back(name, td, init,
                                pDecl->annotation ? *pDecl->annotation : AnnotationArgumentList(),
                                pDecl->init_via_move, pDecl->at);
                        }
                    } else {
                        if ( pDecl->override ) {
                                auto init = pDecl->pInit ? ExpressionPtr(pDecl->pInit->clone()) : nullptr;
                                oldFd->init = init;
                                oldFd->parentType = oldFd->type->isAuto();
                        } else {
                            das_yyerror("structure field is already declared "+name
                                +", use override to replace initial value instead",pDecl->at,
                                    CompilationError::invalid_override);
                        }
                    }
                }
            }
            if ( $annL ) {
                for ( auto pA : *$annL ) {
                    if ( pA->annotation ) {
                        if ( pA->annotation->rtti_isStructureAnnotation() ) {
                            auto ann = static_pointer_cast<StructureAnnotation>(pA->annotation);
                            string err;
                            if ( !ann->touch(pStruct, *g_Program->thisModuleGroup, pA->arguments, err) ) {
                                das_yyerror("can't 'touch' with structure annotation\n" + err,
                                    tokAt(@loc), CompilationError::invalid_annotation);
                            }
                        } else if ( pA->annotation->rtti_isStructureTypeAnnotation() ) {
                            if ( $annL->size()!=1 ) {
                                das_yyerror("structures are only allowed one structure type annotation", tokAt(@loc),
                                    CompilationError::invalid_annotation);
                            } else {
                                if ( !g_Program->addStructureHandle(pStruct,
                                    static_pointer_cast<StructureTypeAnnotation>(pA->annotation), pA->arguments) ) {
                                        das_yyerror("handled structure is already defined "+pStruct->name,tokAt(@loc),
                                        CompilationError::structure_already_declared);
                                } else {
                                    pStruct->module->removeStructure(pStruct);
                                }
                            }
                        }
                    }
                }
				swap ( pStruct->annotations, *$annL );
                delete $annL;
            }
        }
        deleteVariableDeclarationList($list);
    }
    ;

variable_name_list
    :   NAME[name]  {
		das_checkName(*$name,tokAt(@name));
        auto pSL = new vector<string>();
        pSL->push_back(*$name);
        $$ = pSL;
        delete $name;
    }
    |   variable_name_list[list] ',' NAME[name] {
		das_checkName(*$name,tokAt(@name));
        $list->push_back(*$name);
        $$ = $list;
        delete $name;
    }
    ;

basic_type_declaration
    :   DAS_TBOOL       { $$ = Type::tBool; }
    |   DAS_TSTRING     { $$ = Type::tString; }
    |   DAS_TINT        { $$ = Type::tInt; }
    |   DAS_TINT8       { $$ = Type::tInt8; }
    |   DAS_TINT16      { $$ = Type::tInt16; }
    |   DAS_TINT64      { $$ = Type::tInt64; }
    |   DAS_TINT2       { $$ = Type::tInt2; }
    |   DAS_TINT3       { $$ = Type::tInt3; }
    |   DAS_TINT4       { $$ = Type::tInt4; }
    |   DAS_TUINT       { $$ = Type::tUInt; }
    |   DAS_TUINT8      { $$ = Type::tUInt8; }
    |   DAS_TUINT16     { $$ = Type::tUInt16; }
    |   DAS_TUINT64     { $$ = Type::tUInt64; }
    |   DAS_TUINT2      { $$ = Type::tUInt2; }
    |   DAS_TUINT3      { $$ = Type::tUInt3; }
    |   DAS_TUINT4      { $$ = Type::tUInt4; }
    |   DAS_TFLOAT      { $$ = Type::tFloat; }
    |   DAS_TFLOAT2     { $$ = Type::tFloat2; }
    |   DAS_TFLOAT3     { $$ = Type::tFloat3; }
    |   DAS_TFLOAT4     { $$ = Type::tFloat4; }
    |   DAS_TVOID       { $$ = Type::tVoid; }
    |   DAS_TRANGE      { $$ = Type::tRange; }
    |   DAS_TURANGE     { $$ = Type::tURange; }
    |   DAS_TDOUBLE     { $$ = Type::tDouble; }
    ;

structure_type_declaration
    :   name_in_namespace[name]  {
        $$ = g_Program->makeTypeDeclaration(tokAt(@name),*$name);
        if ( !$$ ) {
            $$ = new TypeDecl(Type::tVoid);
        }
        delete $name;
    }
    ;

auto_type_declaration
    :   DAS_TAUTO[loc] {
        $$ = new TypeDecl(Type::autoinfer);
        $$->at = tokAt(@loc);
    }
    |   DAS_TAUTO[loc] '(' NAME[alias] ')'  {
		das_checkName(*$alias,tokAt(@alias));
        $$ = new TypeDecl(Type::autoinfer);
        $$->at = tokAt(@loc);
        $$->alias = *$alias;
        delete $alias;
    }
    ;

type_declaration
    :   basic_type_declaration[basicType]                   { $$ = new TypeDecl($basicType); $$->at = tokAt(@basicType); }
    |   auto_type_declaration[typeDecl]                     { $$ = $typeDecl; }
    |   structure_type_declaration[typeDecl]                { $$ = $typeDecl; }
    |   type_declaration[typeDecl] '[' expr[dimExpr] ']' {
        int32_t dI = TypeDecl::dimConst;
        if ( $dimExpr->rtti_isConstant() ) {                // note: this shortcut is here so we don't get extra infer pass on every array
            auto cI = (ExprConst *) $dimExpr;
            auto bt = cI->baseType;
            if ( bt==Type::tInt || bt==Type::tUInt ) {
                dI = cast<int32_t>::to(cI->value);
            }
        }
        $typeDecl->dim.push_back(dI);
        $typeDecl->dimExpr.push_back(ExpressionPtr($dimExpr));
        $typeDecl->removeDim = false;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] '[' ']' {
        $typeDecl->dim.push_back(TypeDecl::dimAuto);
        $typeDecl->dimExpr.push_back(nullptr);
        $typeDecl->removeDim = false;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] DAS_DELETE '[' ']' {
        $typeDecl->removeDim = true;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] DAS_CONST {
        $typeDecl->constant = true;
        $typeDecl->removeConstant = false;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] DAS_DELETE DAS_CONST {
        $typeDecl->constant = false;
        $typeDecl->removeConstant = true;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] '&' {
        $typeDecl->ref = true;
        $typeDecl->removeRef = false;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] DAS_DELETE '&' {
        $typeDecl->ref = false;
        $typeDecl->removeRef = true;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] DAS_DELETE DAS_CONST '&' {
        $typeDecl->constant = false;
        $typeDecl->removeConstant = true;
        $typeDecl->ref = false;
        $typeDecl->removeRef = true;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] '?' {
        $$ = new TypeDecl(Type::tPointer);
        $$->firstType = TypeDeclPtr($typeDecl);
    }
    |   DAS_ARRAY[loc] '<' type_declaration[typeDecl] '>' {
        $$ = new TypeDecl(Type::tArray);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($typeDecl);
    }
    |   DAS_TABLE[loc] '<' type_declaration[keyTypeDecl] ';' type_declaration[valueTypeDecl] '>' {
        $$ = new TypeDecl(Type::tTable);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($keyTypeDecl);
        $$->secondType = TypeDeclPtr($valueTypeDecl);
    }
    |   DAS_ITERATOR[loc] '<' type_declaration[itTypeDecl] '>' {
        $$ = new TypeDecl(Type::tIterator);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($itTypeDecl);
    }
    |   DAS_TBLOCK[loc] {
        $$ = new TypeDecl(Type::tBlock);
        $$->at = tokAt(@loc);
    }
    |   DAS_TBLOCK[loc] '<' type_declaration[blockType] '>' {
        $$ = new TypeDecl(Type::tBlock);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($blockType);
    }
    |   DAS_TBLOCK[loc] '<' optional_function_argument_list[list] optional_function_type[result] '>' {
        $$ = new TypeDecl(Type::tBlock);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($result);
        if ( $list ) {
            varDeclToTypeDecl($$, $list);
            deleteVariableDeclarationList($list);
        }
    }
    |   DAS_TFUNCTION[loc] {
        $$ = new TypeDecl(Type::tFunction);
        $$->at = tokAt(@loc);
    }
    |   DAS_TFUNCTION[loc] '<' type_declaration[blockType] '>' {
        $$ = new TypeDecl(Type::tFunction);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($blockType);
    }
    |   DAS_TFUNCTION[loc] '<' optional_function_argument_list[list] optional_function_type[result] '>' {
        $$ = new TypeDecl(Type::tFunction);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($result);
        if ( $list ) {
            varDeclToTypeDecl($$, $list);
            deleteVariableDeclarationList($list);
        }
    }
    |   DAS_TLAMBDA[loc] {
        $$ = new TypeDecl(Type::tLambda);
        $$->at = tokAt(@loc);
    }
    |   DAS_TLAMBDA[loc] '<' type_declaration[blockType] '>' {
        $$ = new TypeDecl(Type::tLambda);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($blockType);
    }
    |   DAS_TLAMBDA[loc] '<' optional_function_argument_list[list] optional_function_type[result] '>' {
        $$ = new TypeDecl(Type::tLambda);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($result);
        if ( $list ) {
            varDeclToTypeDecl($$, $list);
            deleteVariableDeclarationList($list);
        }
    }
    |   DAS_TTUPLE[loc] '<' tuple_type_list[list] '>' {
        $$ = new TypeDecl(Type::tTuple);
        $$->at = tokAt(@loc);
        varDeclToTypeDecl($$, $list);
        deleteVariableDeclarationList($list);
    }
    ;

make_decl
    :   make_struct_decl[msd]    { $$ = $msd; }
    |   make_dim_decl[mdd]       { $$ = $mdd; }
    |   make_table_decl[mtd]     { $$ = $mtd; }
    |   array_comprehension[mac] { $$ = $mac; }
    ;

make_struct_fields
    :   NAME[fn] copy_or_move[com] expr[value] {
        auto mfd = make_shared<MakeFieldDecl>(tokAt(@fn),*$fn,ExpressionPtr($value),$com);
        delete $fn;
        auto msd = new MakeStruct();
        msd->push_back(mfd);
        $$ = msd;
    }
    |   make_struct_fields[msd] ',' NAME[fn] copy_or_move[com] expr[value] {
        auto mfd = make_shared<MakeFieldDecl>(tokAt(@fn),*$fn,ExpressionPtr($value),$com);
        delete $fn;
        ((MakeStruct *)$msd)->push_back(mfd);
        $$ = $msd;
    }
    ;

make_struct_dim
    :   make_struct_fields[msf] {
        auto msd = new ExprMakeStructure();
        msd->structs.push_back(MakeStructPtr($msf));
        $$ = msd;
    }
    |   make_struct_dim[msd] ';' make_struct_fields[msf] {
        ((ExprMakeStructure *) $msd)->structs.push_back(MakeStructPtr($msf));
        $$ = $msd;
    }
    ;

make_struct_decl
    :   BRABRAB [loc] type_declaration[mkt] make_struct_dim[msd] ']' ']' {
        ((ExprMakeStructure *)$msd)->makeType = TypeDeclPtr($mkt);
        $msd->at = tokAt(@loc);
        $$ = $msd;
    }
    |   BRABRAB [loc] type_declaration[mkt] '(' ')' make_struct_dim[msd] ']' ']' {
        ((ExprMakeStructure *)$msd)->makeType = TypeDeclPtr($mkt);
        ((ExprMakeStructure *)$msd)->useInitializer = true;
        $msd->at = tokAt(@loc);
        $$ = $msd;
    }
    ;

make_tuple
    :   expr[val] {
        $$ = $val;
    }
    |   make_tuple[mkt] ',' expr[val] {
        ExprMakeTuple * mt;
        if ( $mkt->rtti_isMakeTuple() ) {
            mt = static_cast<ExprMakeTuple *>($mkt);
        } else {
            mt = new ExprMakeTuple(tokAt(@mkt));
            mt->values.push_back(ExpressionPtr($mkt));
        }
        mt->values.push_back(ExpressionPtr($val));
        $$ = mt;
    }
    ;

make_map_tuple
    :   expr[kval] MAPTO[mkt] expr[vval] {
        ExprMakeTuple * mt = new ExprMakeTuple(tokAt(@mkt));
        mt->values.push_back(ExpressionPtr($kval));
        mt->values.push_back(ExpressionPtr($vval));
        $$ = mt;
    }
    ;

make_any_tuple
    :   make_tuple[mkt]         { $$ = $mkt; }
    |   make_map_tuple[mkm]     { $$ = $mkm; }
    ;

make_dim
    :   make_any_tuple[val] {
        auto mka = new ExprMakeArray();
        mka->values.push_back(ExpressionPtr($val));
        $$ = mka;
    }
    |   make_dim[mka] ';' make_any_tuple[val] {
        ((ExprMakeArray *) $mka)->values.push_back(ExpressionPtr($val));
        $$ = $mka;
    }
    ;

make_dim_decl
    :   BRABRAB [loc] type_declaration[mkt] make_dim[mka] ']' ']' {
       ((ExprMakeArray *)$mka)->makeType = TypeDeclPtr($mkt);
       $mka->at = tokAt(@loc);
       $$ = $mka;
    }
    |   BRACBRB [loc] type_declaration[mkt] make_dim[mka] '}' ']' {
       ((ExprMakeArray *)$mka)->makeType = TypeDeclPtr($mkt);
       $mka->at = tokAt(@loc);
       $$ = $mka;
       auto tam = g_Program->makeCall(tokAt(@loc),"to_array_move");
       tam->arguments.push_back(ExpressionPtr($mka));
       $$ = tam;
    }
    ;

make_table
    :   make_map_tuple[val] {
        auto mka = new ExprMakeArray();
        mka->values.push_back(ExpressionPtr($val));
        $$ = mka;
    }
    |   make_table[mka] ';' make_map_tuple[val] {
        ((ExprMakeArray *) $mka)->values.push_back(ExpressionPtr($val));
        $$ = $mka;
    }
    ;

make_table_decl
    :   CBRCBRB [loc] make_table[mka] '}' '}' {
        auto mkt = make_shared<TypeDecl>(Type::autoinfer);
        mkt->dim.push_back(TypeDecl::dimAuto);
        ((ExprMakeArray *)$mka)->makeType = mkt;
        $mka->at = tokAt(@loc);
        auto ttm = g_Program->makeCall(tokAt(@loc),"to_table_move");
        ttm->arguments.push_back(ExpressionPtr($mka));
        $$ = ttm;
    }
    ;

array_comprehension_where
    :                               { $$ = nullptr; }
    |   ';' DAS_WHERE expr[clause]  { $$ = $clause; }
    ;

array_comprehension
    :   BRABRAB DAS_FOR[loc] variable_name_list[iters] DAS_IN expr_list[srcs]  ';' expr[subexpr] array_comprehension_where[where] ']' ']' {
        auto pFor = make_shared<ExprFor>(tokAt(@loc));
        pFor->iterators = *$iters;
        delete $iters;
        pFor->sources = sequenceToList($srcs);
        auto pAC = new ExprArrayComprehension(tokAt(@loc));
        pAC->exprFor = pFor;
        pAC->subexpr = ExpressionPtr($subexpr);
        if ( $where ) {
            pAC->exprWhere = ExpressionPtr($where);
        }
        $$ = pAC;
    }
    ;

%%

void das_checkName(const string & name, const LineInfo &at) {
	if ( name.length()>=2 && name[0]=='_' && name[1]=='_' ) {
		g_Program->error("names starting with __ are reserved, " + name,at,CompilationError::invalid_name);
	}
}

void das_yyerror(const string & error, const LineInfo & at, CompilationError cerr) {
    // printf("ERROR %s\n", error.c_str());
    g_Program->error(error,at,cerr);
}

void das_yyerror(const string & error, CompilationError cerr) {
    // printf("ERROR %s\n", error.c_str());
    g_Program->error(error,LineInfo(g_FileAccessStack.back(),
        yylloc.first_column,yylloc.first_line),cerr);
}

vector<ExpressionPtr> sequenceToList ( Expression * arguments ) {
    vector<ExpressionPtr> argList;
    auto arg = arguments;
    if ( arg->rtti_isSequence() ) {
        while ( arg->rtti_isSequence() ) {
            auto pSeq = static_cast<ExprSequence *>(arg);
            DAS_ASSERT(!pSeq->right->rtti_isSequence());
            argList.push_back(pSeq->right);
            arg = pSeq->left.get();
        }
        argList.push_back(arg->shared_from_this());
        reverse(argList.begin(),argList.end());
        delete arguments;
    } else {
        argList.push_back(ExpressionPtr(arg));
    }
    return argList;
}

ExprLooksLikeCall * parseFunctionArguments ( ExprLooksLikeCall * pCall, Expression * arguments ) {
    pCall->arguments = sequenceToList(arguments);
    return pCall;
}

void deleteVariableDeclarationList ( vector<VariableDeclaration *> * list ) {
    if ( !list ) return;
    for ( auto pD : *list )
        delete pD;
    delete list;
}

LineInfo tokAt ( const struct YYLTYPE & li ) {
    return LineInfo(g_FileAccessStack.back(), li.first_column,li.first_line);
}

Annotation * findAnnotation ( const string & name, const LineInfo & at ) {
    auto ann = g_Program->findAnnotation(name);
    if ( ann.size()==1 ) {
        return ann.back().get();
    } else if ( ann.size()==0 ) {
        das_yyerror("annotation " + name + " not found", at, CompilationError::annotation_not_found );
        return nullptr;
    } else {
        string candidates = g_Program->describeCandidates(ann);
        das_yyerror("too many options for annotation " + name + "\n" + candidates, at, CompilationError::annotation_not_found );
        return nullptr;
    }
}

void varDeclToTypeDecl ( TypeDecl * pType, vector<VariableDeclaration*> * list ) {
    for ( auto pDecl : *list ) {
        if ( pDecl->pTypeDecl ) {
            int count = pDecl->pNameList ? int(pDecl->pNameList->size()) : 1;
            for ( int ai=0; ai!=count; ++ai ) {
                auto pVarType = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                if ( pDecl->pInit ) {
                    das_yyerror("can't have default values in type declaration",
                    pDecl->at,CompilationError::cant_initialize);
                }
                pType->argTypes.push_back(pVarType);
            }
        }
    }
}


