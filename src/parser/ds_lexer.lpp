%{
    #include "daScript/misc/platform.h"
    #include <inttypes.h>
    #include "daScript/ast/ast.h"
    #include "ds_parser.hpp"

    #ifndef SCNi64
      #define SCNi64       "lli"
    #endif
    #ifndef SCNu64
      #define SCNu64       "llu"
    #endif
    #ifndef SCNx64
      #define SCNx64       "llx"
    #endif
    
    using namespace das;
    
    #define YY_NO_INPUT
    
    void das_yyerror(const string & error, CompilationError cerr = CompilationError::syntax_error);
    
    int das_current_line_indent = 0;
    int das_indent_level = 0;
    int das_def_tab_size = 4;
    int das_tab_size = das_def_tab_size;   // only 2,4 or 8
    int das_nested_parentheses = 0;
    int das_nested_curly_braces = 0;
	int das_nested_square_braces = 0;
    int das_nested_sb = 0;
    int das_yycolumn = 1;
    int das_c_style_depth = 0;
    bool das_need_oxford_comma = true;
    bool das_in_normal = false;
    vector<int> das_line_no;
    set<string> das_already_include;
    
    #define YY_USER_ACTION \
        das_yylloc.first_line = das_yylloc.last_line = yylineno; \
        das_yylloc.first_column = das_yycolumn; \
        das_yylloc.last_column = das_yycolumn + yyleng - 1; \
        das_yycolumn += yyleng;
        
%}

%option prefix="das_yy"
%option noyywrap
%option never-interactive
%option nounistd
%option yylineno

/* %option debug */

%x indent
%x strb
%x c_comment
%x include
%s normal

%%

<indent>"*/"                        das_yyerror ("Unexpected */", CompilationError::unexpected_close_comment); return LEXER_ERROR;
<indent>"/*"                        BEGIN(c_comment); das_c_style_depth = 1; das_in_normal = false;
<normal>"*/"                        das_yyerror ("Unexpected */", CompilationError::unexpected_close_comment); return LEXER_ERROR;
<normal>"/*"                        BEGIN(c_comment); das_c_style_depth = 1; das_in_normal = true;
<c_comment>"/*"                     das_c_style_depth ++;
<c_comment>"*/" {
    das_c_style_depth --;
    if ( das_c_style_depth==0 ) {
        if ( das_in_normal ) {
            BEGIN(normal);
        } else {
            BEGIN(indent);
        }
    }
}
<c_comment>.                        /* skipping comment body */
<c_comment>[\r\n]                   /* skipping comment eol */
<strb>\"                {
    // assert(nested_sb==0);
    BEGIN(normal);
    return END_STRING;
}
<strb>\{                {
    DAS_ASSERT(das_nested_sb==0);
    das_nested_sb ++;
    BEGIN(normal);
	return BEGIN_STRING_EXPR;
}
<strb>[\t\r]            {
    das_yyerror("string constant exceeds line", CompilationError::string_constant_exceeds_file);
    return LEXER_ERROR;
}
<strb>EOF               {
    das_yyerror("string constant exceeds file", CompilationError::string_constant_exceeds_file);
    return LEXER_ERROR;
}
<strb>\\[\{\"\}]        {
    das_yylval.ch = yytext[1];
    return STRING_CHARACTER;
}
<strb>.                 {
    das_yylval.ch = *yytext;
    return STRING_CHARACTER;
}
<indent>[ \t\r]*\n		/* skip empty line */
<indent>" "             { 
	das_current_line_indent++; 
	#ifdef FLEX_DEBUG
		printf("[ ], indent=%i\n", das_current_line_indent);
	#endif
}
<indent>"\t"            { 
	das_current_line_indent = (das_current_line_indent + das_tab_size) & ~(das_tab_size-1);  
	#ifdef FLEX_DEBUG
		printf("\\t, cli=%i\n", das_current_line_indent);
	#endif
}
<indent>(\/\/.*)*\n     { 
	das_current_line_indent = 0; 
	das_need_oxford_comma = true; 
	das_yycolumn = 1; 
	#ifdef FLEX_DEBUG
		printf("new line\n");
	#endif
}
<indent>.               {
    unput(*yytext);
    if (das_current_line_indent > das_indent_level*das_tab_size ) {
        das_indent_level++;
        #ifdef FLEX_DEBUG
        printf("emit {, cli=%i, indent =%i\n", das_current_line_indent, das_indent_level);
        #endif
        return '{';
    } else if (das_current_line_indent < das_indent_level*das_tab_size ) {
        das_indent_level--;
        #ifdef FLEX_DEBUG
        printf("emit }, cli=%i, indent =%i\n", das_current_line_indent, das_indent_level);
        #endif
        das_yycolumn--;
        return '}';
    } else {
        BEGIN(normal);
    }
}
<indent><<EOF>>         {
    if ( g_FileAccessStack.size()==1 ) {
        if ( das_indent_level ) {
            das_indent_level--;
            unput('\r');
            #ifdef FLEX_DEBUG
            printf("emit }\n");
            #endif
            return '}';
        } else {
            return 0;
        }
    } else {
        yypop_buffer_state();
        g_FileAccessStack.pop_back();
        yylineno = das_line_no.back();
        das_line_no.pop_back();
    }
}

<include>[ \t]*                     /* eat the whitespace */
<include>[^ \t\r\n]+                { /* got the include file name */
    auto cfi = g_FileAccessStack.back();
    string incFileName = g_Access->getIncludeFileName(cfi->name,yytext);
    auto info = g_Access->getFileInfo(incFileName);
    if ( !info ) {
        das_yyerror("can't open "+incFileName);
    } else {
        if ( das_already_include.find(incFileName) == das_already_include.end() ) {
            das_already_include.insert(incFileName);
            g_FileAccessStack.push_back(info);
            das_line_no.push_back(yylineno);
            yylineno = 1;
            yypush_buffer_state(YY_CURRENT_BUFFER);
            yy_scan_bytes(info->source, info->sourceLength);
        }
    }
    BEGIN(normal);
}

<normal>"include"                                       BEGIN(include);
<normal>"for"                                           das_need_oxford_comma = false; return _FOR;
<normal>"while"                                         das_need_oxford_comma = false; return _WHILE;
<normal>"if"                                            das_need_oxford_comma = false; return _IF;
<normal>"elif"                                          das_need_oxford_comma = false; return _ELIF;
<normal>"else"                                          das_need_oxford_comma = false; return _ELSE;
<normal>"finally"                                       das_need_oxford_comma = false; return _FINALLY;
<normal>"def"                                           das_need_oxford_comma = false; return _DEF;
<normal>"with"                                          das_need_oxford_comma = false; return _WITH;
<normal>"let"[ \t\r]*\/\/.*\n                           das_need_oxford_comma = false; unput('\n'); return _LET;
<normal>"let"[ \t\r]*\(                                 das_need_oxford_comma = false; unput('(');  return _LET;
<normal>"let"                                           return _LET;
<normal>"struct"                                        das_need_oxford_comma = false; return _STRUCT;
<normal>"enum"                                          das_need_oxford_comma = false; return _ENUM;
<normal>"try"                                           das_need_oxford_comma = false; return _TRY;
<normal>"recover"                                       das_need_oxford_comma = false; return _CATCH;
<normal>"typedef"                                       das_need_oxford_comma = false; return _TYPEDEF;
<normal>"options"                                       return _OPTIONS;
<normal>"operator"                                      return _OPERATOR;
<normal>"require"                                       return _REQUIRE;
<normal>"block"                                         return _TBLOCK;
<normal>"function"                                      return _TFUNCTION;
<normal>"lambda"                                        return _TLAMBDA;
<normal>"const"                                         return _CONST;
<normal>"cast"                                          return _CAST;
<normal>"upcast"                                        return _UPCAST;
<normal>"override"                                      return _OVERRIDE;
<normal>"expect"                                        return _EXPECT;
<normal>"table"                                         return _TABLE;
<normal>"array"                                         return _ARRAY;
<normal>"in"                                            return _IN;
<normal>"deref"                                         return _DEREF;
<normal>"scope"                                         return _SCOPE;
<normal>"null"                                          return _NULL;
<normal>"return"                                        return _RETURN;
<normal>"break"                                         return _BREAK;
<normal>"typename"                                      return _TYPENAME;
<normal>"type"                                          return _TYPE;
<normal>"new"                                           return _NEWT;
<normal>"delete"                                        return _DELETE;
<normal>"sizeof"                                        return _SIZEOF;
<normal>"true"                                          return _TRUE;
<normal>"false"                                         return _FALSE;
<normal>"auto"                                          return _TAUTO;
<normal>"bool"                                          return _TBOOL;
<normal>"void"                                          return _TVOID;
<normal>"string"                                        return _TSTRING;
<normal>"int"                                           return _TINT;
<normal>"int64"                                         return _TINT64;
<normal>"int2"                                          return _TINT2;
<normal>"int3"                                          return _TINT3;
<normal>"int4"                                          return _TINT4;
<normal>"uint"                                          return _TUINT;
<normal>"uint64"                                        return _TUINT64;
<normal>"uint2"                                         return _TUINT2;
<normal>"uint3"                                         return _TUINT3;
<normal>"uint4"                                         return _TUINT4;
<normal>"double"                                        return _TDOUBLE;
<normal>"float"                                         return _TFLOAT;
<normal>"float2"                                        return _TFLOAT2;
<normal>"float3"                                        return _TFLOAT3;
<normal>"float4"                                        return _TFLOAT4;
<normal>[_[:alpha:]][_[:alnum:]]*                       das_yylval.s = new string(yytext);  return NAME;    // TODO: track allocations
<normal>\"                                  {
        BEGIN(strb);
        return BEGIN_STRING;
    }
<normal>[0-9]+(u|U)(l|L)                return sscanf(yytext, "%" SCNu64, &das_yylval.ui64)!=1 ? LEXER_ERROR : UNSIGNED_LONG_INTEGER;
<normal>[0-9]+(l|L)                     return sscanf(yytext, "%" SCNi64, &das_yylval.i64)!=1 ? LEXER_ERROR : LONG_INTEGER;
<normal>[0-9]+(u|U)                     return sscanf(yytext, "%u",  &das_yylval.ui)!=1 ? LEXER_ERROR : UNSIGNED_INTEGER;
<normal>[0-9]+                          return sscanf(yytext, "%i",  &das_yylval.i)!=1 ? LEXER_ERROR : INTEGER;

<normal>0[xX][0-9a-fA-F]+(u|U)(l|L)     return sscanf(yytext, "%" SCNx64, &das_yylval.ui64)!=1 ? LEXER_ERROR : UNSIGNED_LONG_INTEGER;
<normal>0[xX][0-9a-fA-F]+(l|L)          return sscanf(yytext, "%" SCNx64, &das_yylval.ui64)!=1 ? LEXER_ERROR : UNSIGNED_LONG_INTEGER;
<normal>0[xX][0-9a-fA-F]+(u|U)          return sscanf(yytext, "%i",  &das_yylval.ui)!=1 ? LEXER_ERROR : UNSIGNED_INTEGER;
<normal>0[xX][0-9a-fA-F]+               return sscanf(yytext, "%i",  &das_yylval.ui)!=1 ? LEXER_ERROR : UNSIGNED_INTEGER;

<normal>([0-9]*)?\.[0-9]+([eE][+\-]?[0-9]+)?(f|F)?      return sscanf(yytext, "%lf", &das_yylval.fd)!=1 ? LEXER_ERROR : FLOAT;
<normal>[0-9][0-9]*\.[0-9]+?([eE][+\-]?[0-9]+)?(f|F)?   return sscanf(yytext, "%lf", &das_yylval.fd)!=1 ? LEXER_ERROR : FLOAT;
<normal>[0-9]+(f|F)                                     return sscanf(yytext, "%lf", &das_yylval.fd)!=1 ? LEXER_ERROR : FLOAT;
<normal>[0-9]+[eE][+\-]?[0-9]+(f|F)?                    return sscanf(yytext, "%lf", &das_yylval.fd)!=1 ? LEXER_ERROR : FLOAT;

<normal>([0-9]*)?\.[0-9]+([eE][+\-]?[0-9]+)?lf			return sscanf(yytext, "%lf", &das_yylval.d)!=1 ? LEXER_ERROR : DOUBLE;
<normal>[0-9][0-9]*\.[0-9]+?([eE][+\-]?[0-9]+)?lf		return sscanf(yytext, "%lf", &das_yylval.d)!=1 ? LEXER_ERROR : DOUBLE;
<normal>[0-9]+lf                                        return sscanf(yytext, "%lf", &das_yylval.d)!=1 ? LEXER_ERROR : DOUBLE;
<normal>[0-9]+[eE][+\-]?[0-9]+lf                        return sscanf(yytext, "%lf", &das_yylval.d)!=1 ? LEXER_ERROR : DOUBLE;
<normal>\)                                  {
    if ( !das_nested_parentheses ) {
        das_yyerror("mismatching parentheses", CompilationError::mismatching_parentheses);
        return LEXER_ERROR;
    }
    das_nested_parentheses --;
    return ')';
}
<normal>\(                                  {
    das_nested_parentheses ++;
    return '(';
}
<normal>\]                                  {
    if ( !das_nested_square_braces ) {
        das_yyerror("mismatching square braces", CompilationError::mismatching_parentheses);
        return LEXER_ERROR;
    }
    das_nested_square_braces --;
    return ']';
}
<normal>\[                                  {
    das_nested_square_braces ++;
    return '[';
}
<normal>\}                                  {
    if ( das_nested_sb ) {
        das_nested_sb --;
        if ( !das_nested_sb ) {
            BEGIN(strb);
			return END_STRING_EXPR;
        } else {
            return '}';
        }
    } else {
        if ( !das_nested_curly_braces ) {
            das_yyerror("mismatching curly braces", CompilationError::mismatching_curly_bracers);
            return LEXER_ERROR;
        }
        das_nested_curly_braces --;
        return '}';
    }
}
<normal>\{                                  {
    if ( das_nested_sb ) {
        das_nested_sb ++;
    } else {
        das_nested_curly_braces ++;
    }
    return '{';
}
<normal>"\:\:"                              return COLCOL;
<normal>"\|\>"                              return RPIPE;
<normal>\<\|[ \t\r]*\/\/.*\n                das_need_oxford_comma = false; unput('\n'); return LBPIPE;
<normal>\<\|[ \t\r]*\n                      das_need_oxford_comma = false; unput('\n'); return LBPIPE;
<normal>\<\|[ \t]\$                         das_need_oxford_comma = false; unput('$'); return LBPIPE;
<normal>"\<\|"                              return LPIPE;
<normal>"\?\?"                              return QQ;
<normal>"\?\."                              return QDOT;
<normal>"\-\>"                              return RARROW;
<normal>"\<\-"                              return LARROW;
<normal>"\+\="                              return ADDEQU;
<normal>"\-\="                              return SUBEQU;
<normal>"\/\="                              return DIVEQU;
<normal>"\*\="                              return MULEQU;
<normal>"\%\="                              return MODEQU;
<normal>"\&\="                              return ANDEQU;
<normal>"\|\="                              return OREQU;
<normal>"\^\="                              return XOREQU;
<normal>"\+\+"                              return ADDADD;
<normal>"\-\-"                              return SUBSUB;
<normal>"\<\="                              return LEEQU;
<normal>"\>\="                              return GREQU;
<normal>"\=\="                              return EQUEQU;
<normal>"\!\="                              return NOTEQU;
<normal>[ \t\r]                             /* skip white space */
<normal>(\/\/.*)*\n                        {
    das_yycolumn = 1;
    if  ( !das_nested_parentheses && !das_nested_curly_braces && !das_nested_square_braces ) {
        bool ns = (das_current_line_indent!=0) && das_need_oxford_comma;
        das_current_line_indent = 0;
        das_need_oxford_comma = true;
        BEGIN(indent);
        #ifdef FLEX_DEBUG
        printf("emit ;\n");
        #endif
        if ( ns )
            return ';';
    }
}
<normal>.                                   return *yytext;

%%

extern int das_yydebug;

void das_yybegin(const char * str) {
    das_already_include.clear();
    das_yydebug = 0;
    yylineno = 1;
	das_tab_size = das_def_tab_size;
    das_line_no.clear();
    das_yycolumn = 1;
    das_current_line_indent = 0;
    das_indent_level = 0;
    das_nested_parentheses = 0;
    das_nested_curly_braces = 0;
	das_nested_square_braces = 0;
    das_nested_sb = 0;
    das_need_oxford_comma = true;
    das_c_style_depth = 0;
    BEGIN(normal);
    yy_scan_string(str);
}


