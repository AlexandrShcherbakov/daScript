%code requires {
    #include "platform.h"
    #include "ast.h"
    
    using namespace yzg;
    using namespace std;
    
    namespace yzg { extern ProgramPtr g_Program; extern bool g_CompiledWithErrors; }
    
    struct VariableDeclaration {
        VariableDeclaration ( vector<string> * n, TypeDecl * t ) : pNameList(n), pTypeDecl(t) {}
        ~VariableDeclaration () { delete pNameList; delete pTypeDecl; }
        vector<string>  *pNameList;
        TypeDecl        *pTypeDecl;
    };
    
    __forceinline void deleteVariableDeclarationList ( vector<VariableDeclaration *> * list ) {
        for ( auto pD : *list )
            delete pD;
        delete list;
    }
}

%{
    void yyerror (const char *s);
    int yylex();
    void yybegin(const char * str);
%}

%locations

%union {
    bool                            b;
    int                             i;
    string                          *s;
    vector<string>                  *pNameList;
    Structure                       *pStruct;
    VariableDeclaration             *pVarDecl;
    vector<VariableDeclaration*>    *pVarDeclList;
    TypeDecl                        *pTypeDecl;
    Type                            type;
}

/* keywords */
%token  _STRUCT _LET    _DEF

/* basic types */
%token  _BOOL   _VOID   _STRING
%token  _INT    _INT2   _INT3   _INT4
%token  _UINT   _UINT2  _UINT3  _UINT4
%token  _FLOAT  _FLOAT2 _FLOAT3 _FLOAT4

%token<i> INT
%token<s> NAME

%type <pStruct>         structure_name
%type <pNameList>       variable_name_list
%type <type>            basic_type_declaration
%type <pTypeDecl>       type_declaration
%type <pTypeDecl>       structure_type_declaration
%type <b>               optional_ptr_declaration
%type <pVarDeclList>    variable_declaration_list
%type <pVarDecl>        variable_declaration


%%

program
    :
    | program   structure_declaration
    | program   global_let
    ;

oxford_comma
    :
    |   ';'
    ;

function_declaration
    :   _DEF NAME[name] '(' function_argument_list ')' oxford_comma expression_block
    ;

function_argument_list
    :   function_argument
    |   function_argument ',' function_argument_list
    ;

function_argument
    :   variable_name_list ':' type_declaration
    ;

expression_block
    : '{' expressions '}'
    ;

expressions
    :
    |   expressions expression ';'
    ;

expression
    :   expression_let
    ;

expression_let
    :   _LET oxford_comma '{' variable_declaration_list[list] '}' {
        deleteVariableDeclarationList($list);
    }
    ;

variable_declaration_list
    :                                                                   { $$ = new vector<VariableDeclaration*>(); }
    |   variable_declaration_list[list] variable_declaration[decl] ';'  { $$ = $list; $list->push_back($decl); }
    ;

variable_declaration
    :   variable_name_list[list] ':' type_declaration[typeDecl]         { $$ = new VariableDeclaration($list,$typeDecl); }
    ;

global_let
    :   _LET oxford_comma '{' variable_declaration_list[list] '}' {
        for ( auto pDecl : *$list ) {
            if ( pDecl->pTypeDecl ) {
                for ( const auto & name : *pDecl->pNameList ) {
                    if ( !g_Program->findVariable(name) ) {
                        VariablePtr pVar = make_shared<Variable>();
                        pVar->name = name;
                        pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                        g_Program->globals[name] = pVar;   // TODO: support proper location $typeDecl.firstLine...
                    } else {
                        yyerror("global variable is already declared");
                    }
                }
            }
        }
        deleteVariableDeclarationList($list);
    }
    ;

structure_name
    :   NAME[name]  {
        if ( !g_Program->findStructure(*$name) ) {
            auto pS = g_Program->structures[*$name] = make_shared<yzg::Structure>(*$name);
            $$ = g_Structure = pS.get();
        } else {
            yyerror ( "structure is alredy defined" );
            $$ = g_Structure = nullptr;
        }
    }
    ;

structure_declaration
    : _STRUCT NAME[name] oxford_comma '{' variable_declaration_list[list] '}' {
        if ( !g_Program->findStructure(*$name) ) {
            auto pStruct = g_Program->structures[*$name] = make_shared<yzg::Structure>(*$name);
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl->isVoid() ) {
                    yyerror("structure type can't be void");
                } else if ( pDecl->pTypeDecl->ref ) {
                    yyerror("structure type can't be reference or array of references");
                } else {
                    for ( const auto & name : *pDecl->pNameList ) {
                        if ( !pStruct->findField(name) ) {
                            auto td = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            pStruct->fields.push_back({name, td, 0});   // TODO: support proper location $typeDecl.firstLine...
                        } else {
                            yyerror("structure field is already declared");
                        }
                    }
                }
            }
        } else {
            yyerror ( "structure is alredy defined" );
        }
        deleteVariableDeclarationList($list);
    }
    ;

variable_name_list
    :   NAME[name]  {
        auto pSL = new vector<string>();
        pSL->push_back(*$name);
        $$ = pSL;
    }
    |   variable_name_list[list] ',' NAME[name] {
        $list->push_back(*$name);
        $$ = $list;
    }
    ;

basic_type_declaration
    :   _BOOL       { $$ = Type::tBool; }
    |   _STRING     { $$ = Type::tString; }
    |   _INT        { $$ = Type::tInt; }
    |   _INT2       { $$ = Type::tInt2; }
    |   _INT3       { $$ = Type::tInt3; }
    |   _INT4       { $$ = Type::tInt4; }
    |   _UINT       { $$ = Type::tUInt; }
    |   _UINT2      { $$ = Type::tUInt2; }
    |   _UINT3      { $$ = Type::tUInt3; }
    |   _UINT4      { $$ = Type::tUInt4; }
    |   _FLOAT      { $$ = Type::tFloat; }
    |   _FLOAT2     { $$ = Type::tFloat2; }
    |   _FLOAT3     { $$ = Type::tFloat3; }
    |   _FLOAT4     { $$ = Type::tFloat4; }
    |   _VOID       { $$ = Type::tVoid; }
    ;

optional_ptr_declaration
    :           { $$ = false; }
    |   '*'     { $$ = true; }
    ;

structure_type_declaration
    :   NAME[name] optional_ptr_declaration[ptr] {
        if ( auto pS = g_Program->findStructure(*$name) ) {
            auto pTD = new TypeDecl($ptr ? Type::tPointer : Type::tStructure);
            pTD->structType = pS.get();
            $$ = pTD;
        } else {
            yyerror("undefined structure type");
            $$ = nullptr;
        }
    }
    ;

type_declaration
    :   basic_type_declaration[basicType]               { $$ = new TypeDecl($basicType); }
    |   structure_type_declaration[typeDecl]            { $$ = $typeDecl; }
    |   type_declaration[typeDecl] '[' INT[dimSize] ']' { if ( $typeDecl ) $typeDecl->dim.push_back($dimSize); $$ = $typeDecl; }
    |   type_declaration[typeDecl] '&'                  { if ( $typeDecl ) $typeDecl->ref = true; $$ = $typeDecl; }
    ;

%%

void yyerror(const char *s)
{
    cout << s << " at line " << yylloc.first_line << "\n";
    g_CompiledWithErrors = true;
}
