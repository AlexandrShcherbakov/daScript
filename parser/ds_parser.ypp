%code requires {
    #include "platform.h"
    #include "ast.h"
    
    using namespace yzg;
    using namespace std;
    
    namespace yzg { extern ProgramPtr g_Program; }
    
    struct VariableDeclaration {
        VariableDeclaration ( const LineInfo & a, vector<string> * n, TypeDecl * t, Expression * i )
            : at(a), pNameList(n), pTypeDecl(t), pInit(i) {}
        ~VariableDeclaration () { delete pNameList; delete pTypeDecl; delete pInit; }
        LineInfo        at;
        vector<string>  *pNameList;
        TypeDecl        *pTypeDecl;
        Expression      *pInit;
    };
    
    struct AnnotationDeclaration {
        Annotation * annotation = nullptr;
        AnnotationArgumentList * arguments = nullptr;
    };
    
    typedef vector<AnnotationDeclaration *> AnnotationList;
    
    ExprLooksLikeCall * parseFunctionArguments ( ExprLooksLikeCall * pCall, Expression * arguments );
    vector<ExpressionPtr> sequenceToList ( Expression * arguments );
    void deleteVariableDeclarationList ( vector<VariableDeclaration *> * list );
    
    LineInfo tokAt ( const struct YYLTYPE & li );
    
    Annotation * findAnnotation ( const string & name, const LineInfo & at );
    void deleteAnnotationList ( AnnotationList * pList );
}

%{
	#include "platform.h"
    #include "debug_info.h"
    #include "compilation_errors.h"
    
    void yyerror (const std::string & error, yzg::CompilationError cerr = yzg::CompilationError::syntax_error);
    void yyerror (const std::string & error, const yzg::LineInfo & at, yzg::CompilationError cerr = yzg::CompilationError::unspecified);
    int yylex();
    void yybegin(const char * str);
%}

%locations
%verbose
%debug

%union {
    bool                            b;
    int                             i;
    uint32_t                        ui;
    double                          d;
    string *                        s;
    vector<string> *                pNameList;
    VariableDeclaration *           pVarDecl;
    vector<VariableDeclaration*> *  pVarDeclList;
    TypeDecl *                      pTypeDecl;
    Expression *                    pExpression;
    Type                            type;
    AnnotationArgument *            aa;
    AnnotationArgumentList *        aaList;
    AnnotationDeclaration *         fa;
    AnnotationList *                faList;
}

%destructor { delete $$; } <s>
%destructor { delete $$; } <pNameList>
%destructor { delete $$; } <pVarDecl>
%destructor { deleteVariableDeclarationList($$); } <pVarDeclList>
%destructor { delete $$; } <pTypeDecl>
%destructor { delete $$; } <pExpression>
%destructor { delete $$; } <aa>
%destructor { delete $$; } <aaList>
%destructor { delete $$; } <fa>
%destructor { delete $$; } <faList>

%token  LEXER_ERROR

/* keywords */
%token  _STRUCT     _LET        _DEF        _WHILE
%token  _IF         _ELSE       _FOR        _CATCH
%token  _TRUE       _FALSE      _SIZEOF     _NEW
%token  _TYPE       _IN         _ELIF       _ARRAY
%token  _RETURN     _NULL       _BREAK      _TRY
%token  _WHERE      _TABLE      _EXPECT     _CONST
%token  _REQUIRE    _OPERATOR

/* basic types */
%token  _BOOL   _VOID   _STRING
%token  _INT    _INT2   _INT3   _INT4
%token  _UINT   _UINT2  _UINT3  _UINT4
%token  _FLOAT  _FLOAT2 _FLOAT3 _FLOAT4
%token  _RANGE  _URANGE _BLOCK

/* operators */
%token  ADDEQU      SUBEQU      DIVEQU      MULEQU      MODEQU
%token  SHLEQU      SHREQU      ANDEQU      OREQU       XOREQU
%token  SHL         SHR         ADDADD      SUBSUB      LEEQU
%token  GREQU       EQUEQU      NOTEQU      RARROW      LARROW
%token  QQ          QDOT        LPIPE       LBPIPE      RPIPE

%token<i>   INTEGER
%token<ui>  UNSIGNED_INTEGER
%token<d>   DOUBLE
%token<s>   STRING
%token<s>   NAME

%type <pNameList>       variable_name_list
%type <type>            basic_type_declaration
%type <pTypeDecl>       type_declaration
%type <pTypeDecl>       optional_function_type
%type <pTypeDecl>       structure_type_declaration
%type <pVarDeclList>    variable_declaration_list
%type <pVarDeclList>    struct_variable_declaration_list
%type <pVarDeclList>    optional_function_argument_list
%type <pVarDeclList>    function_argument_list
%type <pVarDecl>        variable_declaration
%type <s>               name_in_namespace
%type <s>               function_name
%type <aa>              annotation_argument
%type <aaList>          annotation_argument_list
%type <fa>              annotation_declaration
%type <faList>          annotation_list
%type <faList>          optional_annotation_list

%type <pExpression>     expr
%type <pExpression>     expr_list
%type <pExpression>     expression_let
%type <pExpression>     expressions
%type <pExpression>     expression_block
%type <pExpression>     expression_while_loop
%type <pExpression>     expression_for_loop
%type <pExpression>     expression_break
%type <pExpression>     expression_return
%type <pExpression>     expression_else
%type <pExpression>     expression_if_then_else
%type <pExpression>     expression_try_catch
%type <pExpression>     expr_new
%type <pExpression>     expr_pipe
%type <pExpression>     expr_sizeof
%type <pExpression>     expr_block
%type <pExpression>     expression_any
%type <pExpression>     optional_initializer

/* operation precedence*/
%left       ','
%right      '=' ADDEQU SUBEQU DIVEQU MULEQU MODEQU SHREQU SHLEQU ANDEQU OREQU XOREQU LARROW
%right      '?' ':'
%left       '|'
%left       '^'
%left       '&'
%left       EQUEQU NOTEQU
%left       '<' '>' LEEQU GREQU
%left       SHR SHL
%left       '-' '+'
%left       '*' '/' '%'
%left       QQ
%right      UNARY_MINUS UNARY_PLUS '~' '!' PRE_INC PRE_DEC ADDADD SUBSUB
%left       LPIPE RPIPE LBPIPE
%left       POST_INC POST_DEC '.' '[' ']' '(' ')' RARROW QDOT
%nonassoc   COLCOL

%%

program
    :
    |   program structure_declaration
    |   program global_let
    |   program function_declaration
    |   program expect_declaration
    |   program require_declaration
    ;

require_declaration
    :   _REQUIRE require_list
    ;

require_list
    :   require_module
    |   require_list ',' require_module
    ;

require_module
    :   NAME[name] {
        if ( auto mod = Module::require(*$name) ) {
            g_Program->addModule(mod);
        } else {
            yyerror("required module not found " + *$name,tokAt(@name),CompilationError::module_not_found);
        }
        delete $name;
    }
    ;

expect_declaration
    :   _EXPECT expect_list
    ;

expect_list
    :   expect_error
    |   expect_list ',' expect_error
    ;

expect_error
    : INTEGER[err] {
        g_Program->expectErrors[CompilationError($err)] ++;
    }
    | INTEGER[err] ':' INTEGER[count] {
        g_Program->expectErrors[CompilationError($err)] += $count;
    }
    ;

expression_else
    :                                                   { $$ = nullptr; }
    |   _ELSE expression_block[block]                   { $$ = $block; }
    |   _ELIF[loc] expr[cond] expression_block[block] expression_else[then] {
        $$ = new ExprIfThenElse(tokAt(@loc),ExpressionPtr($cond),ExpressionPtr($block),ExpressionPtr($then));
    }
    ;

expression_if_then_else
    :   _IF[loc] expr[cond] expression_block[block] expression_else[then] {
        $$ = new ExprIfThenElse(tokAt(@loc),ExpressionPtr($cond),ExpressionPtr($block),ExpressionPtr($then));
    }
    ;

expression_for_loop
    :   _FOR[loc] variable_name_list[iters] _IN expr_list[srcs] expression_block[block] {
        auto pFor = new ExprFor(tokAt(@loc));
        pFor->iterators = *$iters;
        delete $iters;
        pFor->sources = sequenceToList($srcs);
        pFor->subexpr = ExpressionPtr($block);
        $$ = pFor;
    }
    |   _FOR[loc] variable_name_list[iters] _IN expr_list[srcs] _WHERE expr[filter] expression_block[block] {
        auto pFor = new ExprFor(tokAt(@loc));
        pFor->iterators = *$iters;
        delete $iters;
        pFor->sources = sequenceToList($srcs);
        pFor->subexpr = ExpressionPtr($block);
        pFor->filter = ExpressionPtr($filter);
        $$ = pFor;
    }
    ;

expression_while_loop
    :   _WHILE expr[condition] expression_block[block] {
        auto pWhile = new ExprWhile();
        pWhile->cond = ExpressionPtr($condition);
        pWhile->body = ExpressionPtr($block);
        $$ = pWhile;
    }
    ;

annotation_argument
    :   NAME[name] '=' STRING[value]    { $$ = new AnnotationArgument(*$name,*$value); delete $value; }
    |   NAME[name] '=' INTEGER[value]   { $$ = new AnnotationArgument(*$name,$value);  }
    |   NAME[name] '=' DOUBLE[value]    { $$ = new AnnotationArgument(*$name,float($value));  }
    |   NAME[name] '=' _TRUE            { $$ = new AnnotationArgument(*$name,true);  }
    |   NAME[name] '=' _FALSE           { $$ = new AnnotationArgument(*$name,false);  }
    ;

annotation_argument_list
    :   annotation_argument[arg]  {
        $$ = new AnnotationArgumentList();
        $$->arguments.push_back(*$arg);
        delete $arg;
    }
    |   annotation_argument_list[argL] ',' annotation_argument[arg] {
            $$ = $argL;
            $$->arguments.push_back(*$arg);
            delete $arg;
    }
    ;

annotation_declaration
    :   name_in_namespace[name] {
        $$ = new AnnotationDeclaration();
        $$->annotation = findAnnotation(*$name,tokAt(@name));
        delete $name;
    }
    |   name_in_namespace[name] '(' annotation_argument_list[argL] ')' {
        $$ = new AnnotationDeclaration();
        $$->annotation = findAnnotation(*$name,tokAt(@name));
        $$->arguments = $argL;
        delete $name;
    }
    ;

annotation_list
    :   annotation_declaration[ann]                             { $$ = new AnnotationList(); $$->push_back($ann); }
    |   annotation_list[annL] ',' annotation_declaration[ann]   { $$ = $annL; $$->push_back($ann); }
    ;

optional_annotation_list
    :                                   { $$ = nullptr; }
    |   '[' annotation_list[annL] ']'   { $$ = $annL; }
    ;

optional_function_argument_list
    :                                           { $$ = nullptr; }
    |   '(' ')'                                 { $$ = nullptr; }
    |   '(' function_argument_list[list] ')'    { $$ = $list; }
    ;

optional_function_type
    :                                   { $$ = new TypeDecl(Type::tVoid); }
    |   ':' type_declaration[typeDecl]  { $$ = $typeDecl; $$->at = tokAt(@typeDecl); }
    ;

function_name
    :   NAME[name]        { $$ = $name; }
    |   _OPERATOR '!'     { $$ = new string("!"); }
    |   _OPERATOR '~'     { $$ = new string("~"); }
    |   _OPERATOR ADDEQU  { $$ = new string("+="); }
    |   _OPERATOR SUBEQU  { $$ = new string("-="); }
    |   _OPERATOR MULEQU  { $$ = new string("*="); }
    |   _OPERATOR DIVEQU  { $$ = new string("/="); }
    |   _OPERATOR MODEQU  { $$ = new string("%="); }
    |   _OPERATOR '+'     { $$ = new string("+"); }
    |   _OPERATOR '-'     { $$ = new string("-"); }
    |   _OPERATOR '*'     { $$ = new string("*"); }
    |   _OPERATOR '/'     { $$ = new string("/"); }
    |   _OPERATOR '%'     { $$ = new string("%"); }
    |   _OPERATOR '<'     { $$ = new string("<"); }
    |   _OPERATOR '>'     { $$ = new string(">"); }
    |   _OPERATOR EQUEQU  { $$ = new string("=="); }
    |   _OPERATOR NOTEQU  { $$ = new string("!="); }
    |   _OPERATOR LEEQU   { $$ = new string("<="); }
    |   _OPERATOR GREQU   { $$ = new string(">="); }
    |   _OPERATOR '&'     { $$ = new string("&"); }
    |   _OPERATOR '|'     { $$ = new string("|"); }
    |   _OPERATOR '^'     { $$ = new string("^"); }
    |   ADDADD _OPERATOR  { $$ = new string("++"); }
    |   SUBSUB _OPERATOR  { $$ = new string("--"); }
    |   _OPERATOR ADDADD  { $$ = new string("+++"); }
    |   _OPERATOR SUBSUB  { $$ = new string("---"); }
    ;

function_declaration
    :   optional_annotation_list[annL] _DEF[loc] function_name[name]
            optional_function_argument_list[list] optional_function_type[result] expression_block[block] {
        auto pFunction = make_shared<Function>();
        pFunction->name = *$name;
        pFunction->body = ExpressionPtr($block);
        pFunction->result = TypeDeclPtr($result);
        if ( pFunction->result->dim.size() ) {
            yyerror("function " + *$name + " can't return array",tokAt(@loc),CompilationError::invalid_return_type);
        } else if ( pFunction->result->isRef()) {
            yyerror("function " + *$name + " can't return reference or boxed type",tokAt(@loc),CompilationError::invalid_return_type);
        }
        if ( $list ) {
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl ) {
                    for ( const auto & name : *pDecl->pNameList ) {
                        if ( !pFunction->findArgument(name) ) {
                            VariablePtr pVar = make_shared<Variable>();
                            pVar->name = name;
                            pVar->at = pDecl->at;
                            pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            if ( pVar->type->ref && pVar->type->isRefType() ) {
                                yyerror("can't pass boxed type by reference",pVar->at,CompilationError::invalid_argument_type);
                            }
                            if ( pDecl->pInit ) {
                                pVar->init = ExpressionPtr(pDecl->pInit->clone());
                            }
                            pFunction->arguments.push_back(pVar);
                        } else {
                            yyerror("function argument is already declared " + name,pDecl->at,CompilationError::argument_already_declared);
                        }
                    }
                }
            }
            deleteVariableDeclarationList($list);
        }
        if ( $annL ) {
            for ( auto pA : *$annL ) {
                if ( pA->annotation ) {
                    if ( pA->annotation->isFunctionAnnotation() ) {
                        auto ann = (FunctionAnnotation *) pA->annotation;
                        string err;
                        if ( !ann->apply(pFunction, pA->arguments ? *pA->arguments : AnnotationArgumentList(), err) ) {
                            yyerror("can't apply annotation\n" + err, tokAt(@loc), CompilationError::invalid_annotation);
                        }
                    } else {
                        yyerror("function can only have function annotations", tokAt(@loc), CompilationError::invalid_annotation);
                    }
                }
            }
            deleteAnnotationList($annL);
        }
        if ( !g_Program->addFunction(pFunction) ) {
            yyerror("function already defined " + pFunction->getMangledName(),tokAt(@loc),CompilationError::function_already_declared);
            pFunction.reset();
        }
        delete $name;
    }
    ;

expression_block
    :   '{' expressions[block] '}'          { $$ = $block; }
    ;

expression_any
    :   ';'                                 { $$ = nullptr; }
    |   expr[subexpr] ';'                   { $$ = $subexpr; }
    |   expr_pipe[subexpr]                  { $$ = $subexpr; }
    |   expression_let[subexpr]             { $$ = $subexpr; }
    |   expression_while_loop[subexpr]      { $$ = $subexpr; }
    |   expression_for_loop[subexpr]        { $$ = $subexpr; }
    |   expression_break[subexpr] ';'       { $$ = $subexpr; }
    |   expression_return[subexpr] ';'      { $$ = $subexpr; }
    |   expression_if_then_else[subexpr]    { $$ = $subexpr; }
    |   expression_try_catch[subexpr]       { $$ = $subexpr; }
    ;

expressions
    :                                                   { $$ = new ExprBlock(); }
    |   expressions[block] expression_any[subexpr]      {
        $$ = $block;
        if ( $subexpr ) {
            static_cast<ExprBlock*>($block)->list.push_back(ExpressionPtr($subexpr));
        }
    }
    |   expressions[block] error {
        delete $block; $$ = nullptr; YYABORT;
    }
    ;

expr_pipe
    :   expr[fncall] LBPIPE[loc] expr_block[arg] {
        Expression * pipeCall = $fncall->tail();
        if ( pipeCall->rtti_isCall() ) {
            auto pCall = (ExprLooksLikeCall *) pipeCall;
            pCall->arguments.push_back(ExpressionPtr($arg));
            $$ = $fncall;
        } else {
            yyerror("can only pipe into function call",tokAt(@loc),CompilationError::cant_pipe);
            $$ = $fncall;
        }
    }
    ;

name_in_namespace
    :   NAME[name]                             { $$ = $name; }
    |   NAME[namespace] COLCOL NAME[name]      {
            *$namespace += "::";
            *$namespace += *$name;
            delete $name;
            $$ = $namespace;
        }
    |   COLCOL NAME[name]                      { *$name = "::" + *$name; $$ = $name; }
    ;

expr_new
    :   _NEW[loc] name_in_namespace[structName]   {
        auto pTypeDecl = g_Program->makeTypeDeclaration(tokAt(@loc), *$structName);
        $$ = new ExprNew(tokAt(@loc),TypeDeclPtr(pTypeDecl));
        delete $structName;
    }
    ;

expression_break
    :   _BREAK[loc] { $$ = new ExprBreak(tokAt(@loc)); }
    ;

expression_return
    :   _RETURN[loc]                    { $$ = new ExprReturn(tokAt(@loc),nullptr); }
    |   _RETURN[loc] expr[subexpr]      { $$ = new ExprReturn(tokAt(@loc),ExpressionPtr($subexpr)); }
    ;

expression_try_catch
    :   _TRY[loc] expression_block[tryBlock] _CATCH expression_block[catchBlock] {
        $$ = new ExprTryCatch(tokAt(@loc),ExpressionPtr($tryBlock),ExpressionPtr($catchBlock));
    }
    ;

expression_let
    :   _LET '(' variable_declaration_list[list] ')' expression_block[subexpr] {
        auto pLet = new ExprLet();
        pLet->subexpr = ExpressionPtr($subexpr);
        for ( auto pDecl : *$list ) {
            if ( pDecl->pTypeDecl ) {
                for ( const auto & name : *pDecl->pNameList ) {
                    if ( !pLet->find(name) ) {
                        VariablePtr pVar = make_shared<Variable>();
                        pVar->name = name;
                        pVar->at = pDecl->at;
                        pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                        if ( pDecl->pInit ) {
                            pVar->init = pDecl->pInit->clone();
                        }
                        pLet->variables.push_back(pVar);
                    } else {
                        yyerror("local variable is already declared " + name,tokAt(@list),CompilationError::local_variable_already_declared);
                    }
                }
            }
        }
        deleteVariableDeclarationList($list);
        $$ = pLet;
    }
    |   _LET[loc] variable_declaration[decl] ';' {
        auto pLet = new ExprLet();
        pLet->scoped = false;
        if ( $decl->pTypeDecl ) {
            for ( const auto & name : *$decl->pNameList ) {
                if ( !pLet->find(name) ) {
                    VariablePtr pVar = make_shared<Variable>();
                    pVar->name = name;
                    pVar->at = $decl->at;
                    pVar->type = make_shared<TypeDecl>(*$decl->pTypeDecl);
                    if ( $decl->pInit )
                    pVar->init = $decl->pInit->clone();
                    pLet->variables.push_back(pVar);
                } else {
                    yyerror("local variable is already declared " + name,tokAt(@loc),CompilationError::local_variable_already_declared);
                }
            }
        }
        delete $decl;
        $$ = pLet;
    }
    ;

expr_sizeof
    :   _SIZEOF[loc] '(' expr[subexpr] ')'          { $$ = new ExprSizeOf(tokAt(@loc),ExpressionPtr($subexpr)); }
    |   _SIZEOF[loc] '(' _TYPE type_declaration[decl] ')' {
        if ( $decl->ref )
            yyerror("sizeof(type " + $decl->getMangledName() + "), sizing reference is prohibited",tokAt(@loc),CompilationError::sizeof_reference);
        $$ = new ExprConstInt(tokAt(@loc),$decl->getSizeOf());
        delete $decl;
    }
    ;

expr_list
    :   expr[subexpr]                       { $$ = $subexpr; }
    |   expr_list[left] ',' expr[right]     { $$ = new ExprSequence(tokAt(@left),ExpressionPtr($left),ExpressionPtr($right)); }
    ;

expr_block
    :   expression_block[block]             { $$ = new ExprMakeBlock(tokAt(@block),ExpressionPtr($block)); }
    |   '$' optional_function_argument_list[list] optional_function_type[result] expression_block[block] {
        $$ = new ExprMakeBlock(tokAt(@block),ExpressionPtr($block));
        ExprBlock * closure = (ExprBlock *) $block;
        closure->returnType = TypeDeclPtr($result);
        if ( $list ) {
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl ) {
                    for ( const auto & name : *pDecl->pNameList ) {
                        if ( !closure->findArgument(name) ) {
                            VariablePtr pVar = make_shared<Variable>();
                            pVar->name = name;
                            pVar->at = pDecl->at;
                            pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            if ( pVar->type->ref && pVar->type->isRefType() ) {
                                yyerror("can't pass boxed type by reference",pVar->at,
                                    CompilationError::invalid_argument_type);
                            }
                            if ( pDecl->pInit ) {
                                pVar->init = ExpressionPtr(pDecl->pInit->clone());
                            }
                            closure->arguments.push_back(pVar);
                        } else {
                            yyerror("block argument is already declared " + name,
                                pDecl->at,CompilationError::argument_already_declared);
                        }
                    }
                }
            }
            deleteVariableDeclarationList($list);
        }
    }
    ;

expr
    :   _NULL[loc]                            { $$ = new ExprConstPtr(tokAt(@loc),nullptr); }
    |   NAME[name]                            { $$ = new ExprVar(tokAt(@name),*$name); delete $name; }
    |   INTEGER[const]                        { $$ = new ExprConstInt(tokAt(@const),(int32_t)$const); }
    |   UNSIGNED_INTEGER[const]               { $$ = new ExprConstUInt(tokAt(@const),(uint32_t)$const); }
    |   DOUBLE[const]                         { $$ = new ExprConstFloat(tokAt(@const),(float)$const); }
    |   STRING[const]                         { $$ = new ExprConstString(tokAt(@const),*$const); delete $const; }
    |   _TRUE[loc]                            { $$ = new ExprConstBool(tokAt(@loc),true); }
    |   _FALSE[loc]                           { $$ = new ExprConstBool(tokAt(@loc),false); }
    |   '!'[loc] expr[subexpr]                { $$ = new ExprOp1(tokAt(@loc),"!",ExpressionPtr($subexpr)); }
    |   '~'[loc] expr[subexpr]                { $$ = new ExprOp1(tokAt(@loc),"~",ExpressionPtr($subexpr)); }
    |   '+'[loc] expr[subexpr] %prec  UNARY_PLUS  { $$ = new ExprOp1(tokAt(@loc),"+",ExpressionPtr($subexpr)); }
    |   '-'[loc] expr[subexpr] %prec  UNARY_MINUS { $$ = new ExprOp1(tokAt(@loc),"-",ExpressionPtr($subexpr)); }
    |   expr[left] LARROW[loc] expr[right]   { $$ = new ExprMove(tokAt(@loc),ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '='[loc]    expr[right]   { $$ = new ExprCopy(tokAt(@loc),ExpressionPtr($left),ExpressionPtr($right)); }
    |   expr[left] ADDEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"+=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] SUBEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"-=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] MULEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"*=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] DIVEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"/=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] MODEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"%=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '+'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"+", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '-'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"-", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '*'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"*", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '/'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"/", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '%'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"%", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '<'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),"<", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '>'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),">", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] EQUEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"==", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] NOTEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),"!=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] LEEQU[loc]  expr[right]   { $$ = new ExprOp2(tokAt(@loc),"<=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] GREQU[loc]  expr[right]   { $$ = new ExprOp2(tokAt(@loc),">=", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '&'[loc] expr[right]      { $$ = new ExprOp2(tokAt(@loc),"&", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '|'[loc] expr[right]      { $$ = new ExprOp2(tokAt(@loc),"|", ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '^'[loc] expr[right]      { $$ = new ExprOp2(tokAt(@loc),"^", ExpressionPtr($left), ExpressionPtr($right)); }
    |   ADDADD[loc] expr[subexpr] %prec PRE_INC  { $$ = new ExprOp1(tokAt(@loc),"++", ExpressionPtr($subexpr)); }
    |   SUBSUB[loc] expr[subexpr] %prec PRE_DEC  { $$ = new ExprOp1(tokAt(@loc),"--", ExpressionPtr($subexpr)); }
    |   expr[subexpr] ADDADD[loc] %prec POST_INC { $$ = new ExprOp1(tokAt(@loc),"+++", ExpressionPtr($subexpr)); }
    |   expr[subexpr] SUBSUB[loc] %prec POST_DEC { $$ = new ExprOp1(tokAt(@loc),"---", ExpressionPtr($subexpr)); }
    |   '(' expr[subexpr] ')'                    { $$ = $subexpr; }
    |   expr[subexpr] '['[loc] expr[index] ']'   { $$ = new ExprAt(tokAt(@loc), ExpressionPtr($subexpr), ExpressionPtr($index)); }
    |   expr[subexpr] '.'[loc] NAME[name]        { $$ = new ExprField(tokAt(@loc), ExpressionPtr($subexpr), *$name); delete $name; }
    |   expr[subexpr] QDOT[loc] NAME[name]       { $$ = new ExprSafeField(tokAt(@loc), ExpressionPtr($subexpr), *$name); delete $name; }
    |   name_in_namespace[name] '(' ')' {
            $$ = g_Program->makeCall(tokAt(@name),*$name);
            delete $name;
        }
    |   name_in_namespace[name] '(' expr_list[arguments] ')' {
            $$ = parseFunctionArguments(g_Program->makeCall(tokAt(@name),*$name),$arguments);
            delete $name;
        }
    |   basic_type_declaration[type] '(' expr_list[arguments] ')' {
            $$ = parseFunctionArguments(g_Program->makeCall(tokAt(@type),to_string($type)),$arguments);
        }
    |   expr[subexpr] RARROW[loc]               { $$ = new ExprPtr2Ref(tokAt(@loc),ExpressionPtr($subexpr)); }
    |   expr[subexpr] QQ[loc] expr[dval]        { $$ = new ExprNullCoalescing(tokAt(@loc),ExpressionPtr($subexpr),ExpressionPtr($dval)); }
    |   expr[subexpr] '?'[loc] expr[left] ':' expr[right] {
            $$ = new ExprOp3(tokAt(@loc),"?",ExpressionPtr($subexpr),ExpressionPtr($left),ExpressionPtr($right));
        }
    |   expr_sizeof[subexpr]                    { $$ = $subexpr; }
    |   expr_new[subexpr]                       { $$ = $subexpr; }
    |   expr_block[subexpr]                     { $$ = $subexpr; }
    |   expr[fncall] LPIPE[loc] expr[arg] {
        if ( $fncall->rtti_isCall() ) {
            auto pCall = (ExprLooksLikeCall *) $fncall;
            pCall->arguments.push_back(ExpressionPtr($arg));
            $$ = $fncall;
        } else {
            yyerror("can only pipe into function call",tokAt(@loc),CompilationError::cant_pipe);
            $$ = $fncall;
        }
    }
    ;

struct_variable_declaration_list
    :                                                                            { $$ = new vector<VariableDeclaration*>(); }
    |   struct_variable_declaration_list[list] variable_declaration[decl] ';'    { $$ = $list; $list->push_back($decl); }
    ;

variable_declaration_list
    :   variable_declaration[decl]                                      { $$ = new vector<VariableDeclaration*>(); $$->push_back($decl); }
    |   variable_declaration_list[list] ';' variable_declaration[decl]  { $$ = $list; $list->push_back($decl); }
    ;

function_argument_list
    :   variable_declaration[decl]                                      { $$ = new vector<VariableDeclaration*>(); $$->push_back($decl); }
    |   function_argument_list[list] ';' variable_declaration[decl]     { $$ = $list; $list->push_back($decl); }
    ;

optional_initializer
    :                       { $$ = nullptr; }
    |  '=' expr[subexpr]    { $$ = $subexpr; }
    ;

variable_declaration
    :   variable_name_list[list] ':' type_declaration[typeDecl] optional_initializer[init] {
        $$ = new VariableDeclaration(tokAt(@list),$list,$typeDecl,$init);
    }
    ;

global_let
    :   _LET '{' struct_variable_declaration_list[list] '}' {
        for ( auto pDecl : *$list ) {
            if ( pDecl->pTypeDecl ) {
                for ( const auto & name : *pDecl->pNameList ) {
                    VariablePtr pVar = make_shared<Variable>();
                    pVar->name = name;
                    pVar->at = pDecl->at;
                    pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                    if ( pDecl->pInit ) {
                        pVar->init = pDecl->pInit->clone();
                    }
                    if ( !g_Program->addVariable(pVar) )
                        yyerror("global variable is already declared " + name,pDecl->at,CompilationError::global_variable_already_declared);
                }
            }
        }
        deleteVariableDeclarationList($list);
    }
    ;

structure_declaration
    : optional_annotation_list[annL] _STRUCT[loc] NAME[name] '{' struct_variable_declaration_list[list] '}' {
        auto pStruct = make_shared<Structure>(*$name);
        pStruct->at = tokAt(@loc);
        for ( auto pDecl : *$list ) {
            if ( pDecl->pTypeDecl->isVoid() ) {
                yyerror("structure type can't be void",tokAt(@loc),CompilationError::invalid_structure_field_type);
            } else if ( pDecl->pTypeDecl->ref ) {
                yyerror("structure type can't be reference or array of references",tokAt(@loc),CompilationError::invalid_structure_field_type);
            } else if ( pDecl->pInit ) {
                yyerror("structure field can't have initialization",tokAt(@loc),CompilationError::cant_initialize);
            } else {
                for ( const auto & name : *pDecl->pNameList ) {
                    if ( !pStruct->findField(name) ) {
                        auto td = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                        pStruct->fields.emplace_back(name, td, pDecl->at);
                    } else {
                        yyerror("structure field is already declared "+name,pDecl->at,CompilationError::structure_field_already_declared);
                    }
                }
            }
        }
        if ( $annL ) {
            if ( $annL->size()!=1 ) {
                yyerror("structures only allowed one annotation", tokAt(@loc),CompilationError::invalid_annotation);
            } else {
                auto annotation = $annL->back()->annotation;
                auto args = $annL->back()->arguments;
                if ( !annotation->isStructureAnnotation() ) {
                    yyerror("structures only allowed structure annotation", tokAt(@loc),CompilationError::invalid_annotation);
                } else if ( !g_Program->addStructureHandle(pStruct, ((StructureTypeAnnotation *)annotation)->shared_from_this(),
                    args ? *args : AnnotationArgumentList()) ) {
                    yyerror("handled structure is alredy defined "+*$name,tokAt(@loc),CompilationError::structure_already_declared);
                }
            }
            deleteAnnotationList($annL);
        } else {
            if ( !g_Program->addStructure(pStruct) )
                yyerror("structure is alredy defined "+*$name,tokAt(@loc),CompilationError::structure_already_declared);
        }
        deleteVariableDeclarationList($list);
        delete($name);
    }
    ;

variable_name_list
    :   NAME[name]  {
        auto pSL = new vector<string>();
        pSL->push_back(*$name);
        $$ = pSL;
        delete $name;
    }
    |   variable_name_list[list] ',' NAME[name] {
        $list->push_back(*$name);
        $$ = $list;
        delete $name;
    }
    ;

basic_type_declaration
    :   _BOOL       { $$ = Type::tBool; }
    |   _STRING     { $$ = Type::tString; }
    |   _INT        { $$ = Type::tInt; }
    |   _INT2       { $$ = Type::tInt2; }
    |   _INT3       { $$ = Type::tInt3; }
    |   _INT4       { $$ = Type::tInt4; }
    |   _UINT       { $$ = Type::tUInt; }
    |   _UINT2      { $$ = Type::tUInt2; }
    |   _UINT3      { $$ = Type::tUInt3; }
    |   _UINT4      { $$ = Type::tUInt4; }
    |   _FLOAT      { $$ = Type::tFloat; }
    |   _FLOAT2     { $$ = Type::tFloat2; }
    |   _FLOAT3     { $$ = Type::tFloat3; }
    |   _FLOAT4     { $$ = Type::tFloat4; }
    |   _VOID       { $$ = Type::tVoid; }
    |   _RANGE      { $$ = Type::tRange; }
    |   _URANGE     { $$ = Type::tURange; }
    ;

structure_type_declaration
    :   name_in_namespace[name]  {
        $$ = g_Program->makeTypeDeclaration(tokAt(@name),*$name);
        if ( !$$ ) {
            $$ = new TypeDecl(Type::tVoid);
        }
        delete $name;
    }
    ;

type_declaration
    :   basic_type_declaration[basicType]                   { $$ = new TypeDecl($basicType); $$->at = tokAt(@basicType); }
    |   structure_type_declaration[typeDecl]                { $$ = $typeDecl; }
    |   type_declaration[typeDecl] _CONST {
        $typeDecl->constant = true;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] '[' INTEGER[dimSize] ']' {
        if ( $typeDecl->ref ) {
            yyerror("can't be array of references",tokAt(@dimSize),CompilationError::invalid_type);
        }
        $typeDecl->dim.push_back($dimSize);
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] '&' {
        if ( $typeDecl->dim.size() ) {
            yyerror("can't be reference of array",tokAt(@typeDecl),CompilationError::invalid_type);
        }
        if ( $typeDecl->ref ) {
            yyerror("can't be reference of reference",tokAt(@typeDecl),CompilationError::invalid_type);
        }
        if ( $typeDecl->isVoid() ) {
            yyerror("can't be void reference",tokAt(@typeDecl),CompilationError::invalid_type);
        }
        $typeDecl->ref = true;
        $$ = $typeDecl;
    }
    |   type_declaration[typeDecl] '?' {
        if ( $typeDecl->ref ) {
            yyerror("can't be pointer to reference",tokAt(@typeDecl),CompilationError::invalid_type);
        }
        $$ = new TypeDecl(Type::tPointer);
        $$->firstType = TypeDeclPtr($typeDecl);
    }
    |   _ARRAY[loc] '<' type_declaration[typeDecl] '>' {
        if ( $typeDecl->ref ) {
            yyerror("can't have reference in the Array",tokAt(@typeDecl),CompilationError::invalid_array_type);
        } else if ( $typeDecl->isVoid() ) {
            yyerror("can't have void Array",tokAt(@typeDecl),CompilationError::invalid_array_type);
        }
        $$ = new TypeDecl(Type::tArray);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($typeDecl);
    }
    |   _TABLE[loc] '<' type_declaration[keyTypeDecl] ',' type_declaration[valueTypeDecl] '>' {
        if ( $keyTypeDecl->ref || $valueTypeDecl->ref ) {
            yyerror("can't have reference in the Table",tokAt(@loc),CompilationError::invalid_table_type);
        }
        if ( $keyTypeDecl->isVoid() || $valueTypeDecl->isVoid() ) {
            yyerror("can't have void Table",tokAt(@loc),CompilationError::invalid_array_type);
        }
        if ( !$keyTypeDecl->isWorkhorseType() ) {
            yyerror("key has to be basic 'hashable' type",tokAt(@keyTypeDecl),CompilationError::invalid_table_type);
        }
        $$ = new TypeDecl(Type::tTable);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($keyTypeDecl);
        $$->secondType = TypeDeclPtr($valueTypeDecl);
    }
    |   _BLOCK[loc] {
        $$ = new TypeDecl(Type::tBlock);
        $$->at = tokAt(@loc);
    }
    |   _BLOCK[loc] '<' type_declaration[blockType] '>' {
        $$ = new TypeDecl(Type::tBlock);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($blockType);
    }
    |   _BLOCK[loc] '<' optional_function_argument_list[list] optional_function_type[result] '>' {
        $$ = new TypeDecl(Type::tBlock);
        $$->at = tokAt(@loc);
        $$->firstType = TypeDeclPtr($result);
        if ( $list ) {
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl ) {
                    for ( size_t ai=0; ai!= pDecl->pNameList->size(); ++ai ) {
                        auto pVarType = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                        if ( pVarType->ref && pVarType->isRefType() ) {
                            yyerror("can't pass boxed type by reference",
                                pDecl->at,CompilationError::invalid_argument_type);
                        }
                        if ( pDecl->pInit ) {
                            yyerror("can't have default values in block type declaration",
                                pDecl->at,CompilationError::cant_initialize);
                        }
                        $$->argTypes.push_back(pVarType);
                    }
                }
            }
            deleteVariableDeclarationList($list);
        }
    }
    ;

%%

void yyerror(const string & error, const LineInfo & at, CompilationError cerr) {
    g_Program->error(error,at,cerr);
}

void yyerror(const string & error, CompilationError cerr) {
    g_Program->error(error,LineInfo(yylloc.first_column,yylloc.first_line),cerr);
}

vector<ExpressionPtr> sequenceToList ( Expression * arguments ) {
    vector<ExpressionPtr> argList;
    auto arg = arguments;
    if ( arg->rtti_isSequence() ) {
        while ( arg->rtti_isSequence() ) {
            auto pSeq = static_cast<ExprSequence *>(arg);
            assert(!pSeq->right->rtti_isSequence());
            argList.push_back(pSeq->right);
            arg = pSeq->left.get();
        }
        argList.push_back(arg->shared_from_this());
        reverse(argList.begin(),argList.end());
        delete arguments;
    } else {
        argList.push_back(ExpressionPtr(arg));
    }
    return argList;
}

ExprLooksLikeCall * parseFunctionArguments ( ExprLooksLikeCall * pCall, Expression * arguments ) {
    pCall->arguments = sequenceToList(arguments);
    return pCall;
}

void deleteVariableDeclarationList ( vector<VariableDeclaration *> * list ) {
    if ( !list ) return;
    for ( auto pD : *list )
        delete pD;
    delete list;
}

LineInfo tokAt ( const struct YYLTYPE & li ) {
    return LineInfo(li.first_column,li.first_line);
}

Annotation * findAnnotation ( const string & name, const LineInfo & at ) {
    auto ann = g_Program->findAnnotation(name);
    if ( ann.size()==1 ) {
        return ann.back().get();
    } else if ( ann.size()==0 ) {
        yyerror("annotation " + name + " not found", at, CompilationError::annotation_not_found );
        return nullptr;
    } else {
        string candidates = g_Program->describeCandidates(ann);
        yyerror("too many options for annotation " + name, at, CompilationError::annotation_not_found );
        return nullptr;
    }
}

void deleteAnnotationList ( AnnotationList * list ) {
    for ( auto pD : *list )
        delete pD;
    delete list;
}

