%code requires {
    #include "platform.h"
    #include "ast.h"
    
    using namespace yzg;
    using namespace std;
    
    namespace yzg { extern ProgramPtr g_Program; }
    
    struct VariableDeclaration {
        VariableDeclaration ( const LineInfo & a, vector<string> * n, TypeDecl * t, Expression * i )
            : at(a), pNameList(n), pTypeDecl(t), pInit(i) {}
        ~VariableDeclaration () { delete pNameList; delete pTypeDecl; delete pInit; }
        LineInfo        at;
        vector<string>  *pNameList;
        TypeDecl        *pTypeDecl;
        Expression      *pInit;
    };
    
    ExprCall * parseFunctionArguments ( ExprCall * pCall, Expression * arguments );
    void deleteVariableDeclarationList ( vector<VariableDeclaration *> * list );
    
    LineInfo tokAt ( const struct YYLTYPE & li );
}

%{
    void yyerror (const std::string & error);
    int yylex();
    void yybegin(const char * str);
%}

%locations
%verbose
%debug

%union {
    bool                            b;
    int                             i;
    uint                            ui;
    double                          d;
    string                          *s;
    vector<string>                  *pNameList;
    Structure                       *pStruct;
    VariableDeclaration             *pVarDecl;
    vector<VariableDeclaration*>    *pVarDeclList;
    TypeDecl                        *pTypeDecl;
    Expression                      *pExpression;
    Type                            type;
}

%token  LEXER_ERROR

/* keywords */
%token  _STRUCT _LET    _DEF        _WHILE
%token  _IF     _ELSE   _FOREACH    _IN
%token  _TRUE   _FALSE  _SIZEOF     _NEW
%token  _TYPE   _ASSERT _DEBUG      _BREAKPOINT

/* basic types */
%token  _BOOL   _VOID   _STRING
%token  _INT    _INT2   _INT3   _INT4
%token  _UINT   _UINT2  _UINT3  _UINT4
%token  _FLOAT  _FLOAT2 _FLOAT3 _FLOAT4

/* operators */
%token  ADDEQU      SUBEQU      DIVEQU      MULEQU      MODEQU
%token  SHLEQU      SHREQU      ANDEQU      OREQU       XOREQU
%token  SHL         SHR         ADDADD      SUBSUB      LEEQU
%token  GREQU       EQUEQU      NOTEQU      ANDAND      OROR
%token  ARROW

%token<i>   INTEGER
%token<ui>  UNSIGNED_INTEGER
%token<d>   DOUBLE
%token<s>   STRING
%token<s>   NAME

%type <pStruct>         structure_name
%type <pNameList>       variable_name_list
%type <type>            basic_type_declaration
%type <pTypeDecl>       type_declaration
%type <pTypeDecl>       optional_function_type
%type <pTypeDecl>       structure_type_declaration
%type <b>               optional_ptr_declaration
%type <pVarDeclList>    variable_declaration_list
%type <pVarDeclList>    optional_function_argument_list
%type <pVarDeclList>    function_argument_list
%type <pVarDecl>        variable_declaration

%type <pExpression>     expr
%type <pExpression>     expression_let
%type <pExpression>     expressions
%type <pExpression>     expression_block
%type <pExpression>     expression_while_loop
%type <pExpression>     expression_foreach_loop
%type <pExpression>     expression_assert
%type <pExpression>     expr_new
%type <pExpression>     expr_sizeof
%type <pExpression>     expression_any
%type <pExpression>     optional_initializer

/* operation precedence*/
%left   ','
%right  '=' ADDEQU SUBEQU DIVEQU MULEQU MODEQU SHREQU SHLEQU ANDEQU OREQU XOREQU
%right  '?' ':'
%left   OROR
%left   ANDAND
%left   '|'
%left   '^'
%left   '&'
%left   EQUEQU NOTEQU
%left   '<' '>' LEEQU GREQU
%left   SHR SHL
%left   '-' '+'
%left   '*' '/' '%'
%right  UNARY_MINUS UNARY_PLUS '~' '!' PRE_INC PRE_DEC ADDADD SUBSUB
%left   POST_INC POST_DEC '.' '[' ']' '(' ')' ARROW

%%

program
    :
    |   program structure_declaration
    |   program global_let
    |   program function_declaration
    ;

expression_foreach_loop
    :   _FOREACH[loc] expr[iter] _IN expr[head] expression_block[block] {
        auto pForeach = new ExprForeach(tokAt(@loc));
        pForeach->head = ExpressionPtr($head);
        pForeach->iter = ExpressionPtr($iter);
        pForeach->body = ExpressionPtr($block);
        $$ = pForeach;
    }
    ;

expression_while_loop
    :   _WHILE expr[condition] expression_block[block] {
        auto pWhile = new ExprWhile();
        pWhile->cond = ExpressionPtr($condition);
        pWhile->body = ExpressionPtr($block);
        $$ = pWhile;
    }
    ;

optional_function_argument_list
    :                                           { $$ = nullptr; }
    |   '(' function_argument_list[list] ')'    { $$ = $list; }
    ;

optional_function_type
    :                                   { $$ = new TypeDecl(Type::tVoid); }
    |   ':' type_declaration[typeDecl]  { $$ = $typeDecl; $$->at = tokAt(@typeDecl); }
    ;

function_declaration
    :   _DEF NAME[name] optional_function_argument_list[list] optional_function_type[result] expression_block[block] {
        auto pFunction = make_shared<Function>();
        pFunction->name = *$name;
        pFunction->body = ExpressionPtr($block);
        pFunction->result = TypeDeclPtr($result);
        if ( $list ) {
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl ) {
                    for ( const auto & name : *pDecl->pNameList ) {
                        if ( !pFunction->findArgument(name) ) {
                            VariablePtr pVar = make_shared<Variable>();
                            pVar->name = name;
                            pVar->at = pDecl->at;
                            pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            pVar->init = ExpressionPtr(pDecl->pInit);
                            pFunction->arguments.push_back(pVar);
                        } else {
                            yyerror("function argument is already declared " + name);
                        }
                    }
                }
            }
        }
        auto mangledName = pFunction->getMangledName();
        if ( g_Program->findFunction(mangledName) )
            yyerror("function already defined " + mangledName);
        g_Program->functions[mangledName] = pFunction;
        g_Program->functionsByName[pFunction->name].push_back(pFunction);
    }
    ;

expression_block
    :   '{' expressions[block] '}'      { $$ = $block; }
    ;

expression_any
    :   expr[subexpr] ';'                   { $$ = $subexpr; }
    |   expression_let[subexpr]             { $$ = $subexpr; }
    |   expression_while_loop[subexpr]      { $$ = $subexpr; }
    |   expression_foreach_loop[subexpr]    { $$ = $subexpr; }
    |   expression_assert[subexpr]          { $$ = $subexpr; }
    ;

expressions
    :                                                   { $$ = new ExprBlock(); }
    |   expressions[block] expression_any[subexpr]      {
        $$ = $block;
        static_cast<ExprBlock*>($block)->list.push_back(ExpressionPtr($subexpr));
    }
    ;

expr_new
    :   _NEW[loc] NAME[structName]   {
            auto pTypeDecl = make_shared<TypeDecl>(Type::tStructure);
            pTypeDecl->structType = g_Program->findStructure(*$structName).get();
            if ( !pTypeDecl->structType )
                yyerror ( "structure type not found " + *$structName );
            $$ = new ExprNew(tokAt(@loc),pTypeDecl);
    }
    ;

expression_assert
    :   _ASSERT[loc] '(' expr[subexpr] ')' ';'                      { $$ = new ExprAssert(tokAt(@loc),ExpressionPtr($subexpr)); }
    |   _ASSERT[loc] '(' expr[subexpr] ',' STRING[message] ')' ';'  { $$ = new ExprAssert(tokAt(@loc),ExpressionPtr($subexpr),*$message); }
    ;

expression_let
    :   _LET '{' variable_declaration_list[list] '}' _IN expression_block[subexpr] {
        auto pLet = new ExprLet();
        pLet->subexpr = ExpressionPtr($subexpr);
        for ( auto pDecl : *$list ) {
            if ( pDecl->pTypeDecl ) {
                for ( const auto & name : *pDecl->pNameList ) {
                    if ( !pLet->find(name) ) {
                        VariablePtr pVar = make_shared<Variable>();
                        pVar->name = name;
                        pVar->at = pDecl->at;
                        pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                        pVar->init = ExpressionPtr(pDecl->pInit);
                        pLet->variables.push_back(pVar);
                    } else {
                        yyerror("local variable is already declared " + name);
                    }
                }
            }
        }
        $$ = pLet;
    }
    ;

expr_sizeof
    :   _SIZEOF[loc] '(' expr[subexpr] ')'          { $$ = new ExprSizeOf(tokAt(@loc),ExpressionPtr($subexpr)); }
    |   _SIZEOF[loc] '(' _TYPE type_declaration[decl] ')' {
        if ( $decl->ref )
            yyerror("sizeof(type " + $decl->getMangledName() + "), sizing reference is prohibited");
        $$ = new ExprConstInt(tokAt(@loc),$decl->getSizeOf());
        delete $decl;
    }
    ;

expr
    :   NAME[name]                            { $$ = new ExprVar(tokAt(@name),*$name); }
    |   INTEGER[const]                        { $$ = new ExprConstInt(tokAt(@const),(int32_t)$const); }
    |   UNSIGNED_INTEGER[const]               { $$ = new ExprConstUInt(tokAt(@const),(uint32_t)$const); }
    |   DOUBLE[const]                         { $$ = new ExprConstFloat(tokAt(@const),(float)$const); }
    |   STRING[const]                         { $$ = new ExprConstString(tokAt(@const),*$const); }
    |   _TRUE[loc]                            { $$ = new ExprConstBool(tokAt(@loc),true); }
    |   _FALSE[loc]                           { $$ = new ExprConstBool(tokAt(@loc),false); }
    |   '+'[loc] expr[subexpr] %prec  UNARY_PLUS  { $$ = new ExprOp1(tokAt(@loc),Operator::sub,ExpressionPtr($subexpr)); }
    |   '-'[loc] expr[subexpr] %prec  UNARY_MINUS { $$ = new ExprOp1(tokAt(@loc),Operator::add,ExpressionPtr($subexpr)); }
    |   expr[left] '='[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::eq,ExpressionPtr($left),ExpressionPtr($right)); }
    |   expr[left] ADDEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::addEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] SUBEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::subEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] MULEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::mulEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] DIVEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::divEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] MODEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::modEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '+'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::add, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '-'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::sub, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '*'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::mul, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '/'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::div, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '%'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::mod, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '<'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::less, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] '>'[loc]    expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::greater, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] EQUEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::eqEq, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] NOTEQU[loc] expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::notEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] LEEQU[loc]  expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::lessEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   expr[left] GREQU[loc]  expr[right]   { $$ = new ExprOp2(tokAt(@loc),Operator::greaterEqu, ExpressionPtr($left), ExpressionPtr($right)); }
    |   ADDADD[loc] expr[subexpr] %prec PRE_INC  { $$ = new ExprOp1(tokAt(@loc),Operator::inc, ExpressionPtr($subexpr)); }
    |   SUBSUB[loc] expr[subexpr] %prec PRE_DEC  { $$ = new ExprOp1(tokAt(@loc),Operator::dec, ExpressionPtr($subexpr)); }
    |   expr[subexpr] ADDADD[loc] %prec POST_INC { $$ = new ExprOp1(tokAt(@loc),Operator::postInc, ExpressionPtr($subexpr)); }
    |   expr[subexpr] SUBSUB[loc] %prec POST_DEC { $$ = new ExprOp1(tokAt(@loc),Operator::postDec, ExpressionPtr($subexpr)); }
    |   '(' expr[subexpr] ')'                { $$ = $subexpr; }
    |   expr[subexpr] '['[loc] expr[index] ']'   { $$ = new ExprAt(tokAt(@loc), ExpressionPtr($subexpr), ExpressionPtr($index)); }
    |   expr[subexpr] '.'[loc] NAME[name]        { $$ = new ExprField(tokAt(@loc), ExpressionPtr($subexpr), *$name); }
    |   expr[left] ',' expr[right]          { $$ = new ExprSequence(tokAt(@left),ExpressionPtr($left),ExpressionPtr($right)); }
    |   NAME[name] '(' ')'                  { $$ = new ExprCall(tokAt(@name),*$name); }
    |   NAME[name] '(' expr[arguments] ')'  { $$ = parseFunctionArguments(new ExprCall(tokAt(@name),*$name),$arguments); }
    |   basic_type_declaration[type] '(' expr[arguments] ')' {
            $$ = parseFunctionArguments(new ExprCall(tokAt(@type),to_string($type)),$arguments);
        }
    |   expr[subexpr]   ARROW[loc]              { $$ = new ExprPtr2Ref(tokAt(@loc),ExpressionPtr($subexpr)); }
    |   expr_sizeof[subexpr]                    { $$ = $subexpr; }
    |   expr_new[subexpr]                       { $$ = $subexpr; }
    |   _DEBUG[loc] '(' expr[subexpr] ')'                       { $$ = new ExprDebug(tokAt(@loc),ExpressionPtr($subexpr)); }
    |   _DEBUG[loc] '(' expr[subexpr] ',' STRING[message] ')'   { $$ = new ExprDebug(tokAt(@loc),ExpressionPtr($subexpr),*$message); }
    ;

variable_declaration_list
    :                                                                   { $$ = new vector<VariableDeclaration*>(); }
    |   variable_declaration_list[list] variable_declaration[decl] ';'  { $$ = $list; $list->push_back($decl); }
    ;

function_argument_list
    :   variable_declaration[decl]                                      { $$ = new vector<VariableDeclaration*>(); $$->push_back($decl); }
    |   function_argument_list[list] ';' variable_declaration[decl]     { $$ = $list; $list->push_back($decl); }
    ;

optional_initializer
    :                       { $$ = nullptr; }
    |  '=' expr[subexpr]    { $$ = $subexpr; }
    ;

variable_declaration
    :   variable_name_list[list] ':' type_declaration[typeDecl] optional_initializer[init] {
        $$ = new VariableDeclaration(tokAt(@list),$list,$typeDecl,$init);
    }
    ;

global_let
    :   _LET '{' variable_declaration_list[list] '}' {
        for ( auto pDecl : *$list ) {
            if ( pDecl->pTypeDecl ) {
                for ( const auto & name : *pDecl->pNameList ) {
                    if ( !g_Program->findVariable(name) ) {
                        VariablePtr pVar = make_shared<Variable>();
                        pVar->name = name;
                        pVar->at = pDecl->at;
                        pVar->type = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                        pVar->init = ExpressionPtr(pDecl->pInit);
                        g_Program->globals[name] = pVar;
                    } else {
                        yyerror("global variable is already declared " + name);
                    }
                }
            }
        }
        deleteVariableDeclarationList($list);
    }
    ;

structure_declaration
    : _STRUCT[loc] NAME[name] '{' variable_declaration_list[list] '}' {
        if ( !g_Program->findStructure(*$name) ) {
            auto pStruct = g_Program->structures[*$name] = make_shared<Structure>(*$name);
            pStruct->at = tokAt(@loc);
            for ( auto pDecl : *$list ) {
                if ( pDecl->pTypeDecl->isVoid() ) {
                    yyerror("structure type can't be void");
                } else if ( pDecl->pTypeDecl->ref ) {
                    yyerror("structure type can't be reference or array of references");
                } else if ( pDecl->pInit ) {
                    yyerror("structure field can't have initialization");
                } else {
                    for ( const auto & name : *pDecl->pNameList ) {
                        if ( !pStruct->findField(name) ) {
                            auto td = make_shared<TypeDecl>(*pDecl->pTypeDecl);
                            pStruct->fields.push_back({name, td, pDecl->at});
                        } else {
                            yyerror("structure field is already declared " + name);
                        }
                    }
                }
            }
        } else {
            yyerror ( "structure is alredy defined " + *$name );
        }
        deleteVariableDeclarationList($list);
    }
    ;

variable_name_list
    :   NAME[name]  {
        auto pSL = new vector<string>();
        pSL->push_back(*$name);
        $$ = pSL;
    }
    |   variable_name_list[list] ',' NAME[name] {
        $list->push_back(*$name);
        $$ = $list;
    }
    ;

basic_type_declaration
    :   _BOOL       { $$ = Type::tBool; }
    |   _STRING     { $$ = Type::tString; }
    |   _INT        { $$ = Type::tInt; }
    |   _INT2       { $$ = Type::tInt2; }
    |   _INT3       { $$ = Type::tInt3; }
    |   _INT4       { $$ = Type::tInt4; }
    |   _UINT       { $$ = Type::tUInt; }
    |   _UINT2      { $$ = Type::tUInt2; }
    |   _UINT3      { $$ = Type::tUInt3; }
    |   _UINT4      { $$ = Type::tUInt4; }
    |   _FLOAT      { $$ = Type::tFloat; }
    |   _FLOAT2     { $$ = Type::tFloat2; }
    |   _FLOAT3     { $$ = Type::tFloat3; }
    |   _FLOAT4     { $$ = Type::tFloat4; }
    |   _VOID       { $$ = Type::tVoid; }
    ;

optional_ptr_declaration
    :           { $$ = false; }
    |   '*'     { $$ = true; }
    ;

structure_type_declaration
    :   NAME[name] optional_ptr_declaration[ptr] {
        if ( auto pS = g_Program->findStructure(*$name) ) {
            auto pTD = new TypeDecl($ptr ? Type::tPointer : Type::tStructure);
            pTD->structType = pS.get();
            pTD->at = tokAt(@name);
            $$ = pTD;
        } else {
            yyerror("undefined structure type");
            $$ = nullptr;
        }
    }
    ;

type_declaration
    :   basic_type_declaration[basicType]                   { $$ = new TypeDecl($basicType); $$->at = tokAt(@basicType); }
    |   structure_type_declaration[typeDecl]                { $$ = $typeDecl; }
    |   type_declaration[typeDecl] '[' INTEGER[dimSize] ']' { if ( $typeDecl ) $typeDecl->dim.push_back($dimSize); $$ = $typeDecl; }
    |   type_declaration[typeDecl] '&'                      { if ( $typeDecl ) $typeDecl->ref = true; $$ = $typeDecl; }
    ;

%%

void yyerror(const string & error)
{
    g_Program->error(error,LineInfo(yylloc.first_column,yylloc.first_line));
}

ExprCall * parseFunctionArguments ( ExprCall * pCall, Expression * arguments ) {
    auto arg = arguments;
    if ( arg->isSequence() ) {
        while ( arg->isSequence() ) {
            auto pSeq = static_cast<ExprSequence *>(arg);
            assert(!pSeq->right->isSequence());
            pCall->arguments.push_back(pSeq->right);
            arg = pSeq->left.get();
        }
        pCall->arguments.push_back(arg->shared_from_this());
        reverse(pCall->arguments.begin(),pCall->arguments.end());
        delete arguments;
    } else {
        pCall->arguments.push_back(ExpressionPtr(arg));
    }
    return pCall;
}

void deleteVariableDeclarationList ( vector<VariableDeclaration *> * list )
{
    for ( auto pD : *list )
        delete pD;
    delete list;
}

LineInfo tokAt ( const struct YYLTYPE & li )
{
    return LineInfo(li.first_column,li.first_line);
}
