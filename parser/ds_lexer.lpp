%{
    #include "platform.h"
    #include "ds_parser.hpp"
    
    #define YY_NO_INPUT
    
    void yyerror(const char *s);
    
    int yyline = 0;
    int current_line_indent = 0;
    int indent_level = 0;
    int tab_size = 4;   // only 2,4 or 8
    int nested_parentheses = 0;
    int nested_curly_braces = 0;
%}

%option noyywrap
%option never-interactive
%option nounistd

/* %option debug */

%x indent
%s normal

%%

<indent>" "      { current_line_indent++; }
<indent>"\t"     { current_line_indent = (current_line_indent + tab_size) & (tab_size-1);  }
<indent>"\n"     { current_line_indent = 0; yyline++; }
<indent>.        {
    unput(*yytext);
    if (current_line_indent > indent_level*tab_size ) {
        indent_level++;
        #ifdef FLEX_DEBUG
        std::cout << "emit {\n";
        #endif
        return '{';
    } else if (current_line_indent < indent_level*tab_size ) {
        indent_level--;
        #ifdef FLEX_DEBUG
        std::cout << "emit }\n";
        #endif
        return '}';
    } else {
        BEGIN(normal);
    }
}
<indent><<EOF>> {
    if ( indent_level ) {
        indent_level--;
        unput('\r');
        #ifdef FLEX_DEBUG
        std::cout << "emit }\n";
        #endif
        return '}';
    } else {
        return 0;
    }
}

<normal>"struct"                            return _STRUCT;
<normal>"bool"                              return _BOOL;
<normal>"void"                              return _VOID;
<normal>"string"                            return _STRING;
<normal>"int"                               return _INT;
<normal>"int2"                              return _INT2;
<normal>"int3"                              return _INT3;
<normal>"int4"                              return _INT4;
<normal>"uint"                              return _UINT;
<normal>"uint2"                             return _UINT2;
<normal>"uint3"                             return _UINT3;
<normal>"uint4"                             return _UINT4;
<normal>"float"                             return _FLOAT;
<normal>"float2"                            return _FLOAT2;
<normal>"float3"                            return _FLOAT3;
<normal>"float4"                            return _FLOAT4;
<normal>[_[:alpha:]][_[:alnum:]]*           yylval.s = new std::string(yytext);  return NAME;
<normal>[[:digit:]]+                        yylval.i = strtol(yytext, NULL, 10); return INT;
<normal>[)]                                 {
    if ( !nested_parentheses )
        yyerror("mismatching parentheses");
    nested_parentheses --;
    return ')';
}
<normal>[(]                                 {
    nested_parentheses ++;
    return '(';
}
<normal>[}]                                 {
    if ( !nested_curly_braces )
        yyerror("mismatching curly braces");
    nested_curly_braces --;
    return '}';
}
<normal>[{]                                 {
    nested_curly_braces ++;
    return '{';
}
<normal>[-+*/;,<\[\]!~%&^|\.$@\?:]       return *yytext;
<normal>[ \t\r]                             /* skip white space */
<normal>\n                                  {
    yyline ++;
    if  ( !nested_parentheses && !nested_curly_braces ) {
        bool ns = current_line_indent!=0;
        current_line_indent = 0;
        BEGIN(indent);
        #ifdef FLEX_DEBUG
        std::cout << "emit ;\n";
        #endif
        if ( ns )
            return ';';
    }
}

%%

void yybegin(const char * str)
{
    BEGIN(normal);
    yyline = 0;
    current_line_indent = 0;
    indent_level = 0;
    nested_curly_braces = 0;
    nested_curly_braces = 0;
    yy_scan_string(str);
}

