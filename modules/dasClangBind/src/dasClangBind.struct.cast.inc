// this file is generated via dasClangBind
// all user modifications will be lost after this file is re-generated

template <> struct cast_arg<CXString> {
	static __forceinline CXString to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXString *>::to(res);
	}
};
template <> struct cast_arg<CXStringSet> {
	static __forceinline CXStringSet to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXStringSet *>::to(res);
	}
};
template <> struct cast_arg<CXUnsavedFile> {
	static __forceinline CXUnsavedFile to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXUnsavedFile *>::to(res);
	}
};
template <> struct cast_arg<CXVersion> {
	static __forceinline CXVersion to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXVersion *>::to(res);
	}
};
template <> struct cast_arg<CXFileUniqueID> {
	static __forceinline CXFileUniqueID to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXFileUniqueID *>::to(res);
	}
};
template <> struct cast_arg<CXSourceLocation> {
	static __forceinline CXSourceLocation to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXSourceLocation *>::to(res);
	}
};
template <> struct cast_arg<CXSourceRange> {
	static __forceinline CXSourceRange to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXSourceRange *>::to(res);
	}
};
template <> struct cast_arg<CXSourceRangeList> {
	static __forceinline CXSourceRangeList to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXSourceRangeList *>::to(res);
	}
};
template <> struct cast_arg<CXTUResourceUsageEntry> {
	static __forceinline CXTUResourceUsageEntry to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXTUResourceUsageEntry *>::to(res);
	}
};
template <> struct cast_arg<CXTUResourceUsage> {
	static __forceinline CXTUResourceUsage to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXTUResourceUsage *>::to(res);
	}
};
template <> struct cast_arg<CXCursor> {
	static __forceinline CXCursor to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCursor *>::to(res);
	}
};
template <> struct cast_arg<CXPlatformAvailability> {
	static __forceinline CXPlatformAvailability to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXPlatformAvailability *>::to(res);
	}
};
template <> struct cast_arg<CXType> {
	static __forceinline CXType to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXType *>::to(res);
	}
};
template <> struct cast_arg<CXToken> {
	static __forceinline CXToken to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXToken *>::to(res);
	}
};
template <> struct cast_arg<CXCompletionResult> {
	static __forceinline CXCompletionResult to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCompletionResult *>::to(res);
	}
};
template <> struct cast_arg<CXCodeCompleteResults> {
	static __forceinline CXCodeCompleteResults to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCodeCompleteResults *>::to(res);
	}
};
template <> struct cast_arg<CXCursorAndRangeVisitor> {
	static __forceinline CXCursorAndRangeVisitor to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCursorAndRangeVisitor *>::to(res);
	}
};
template <> struct cast_arg<CXIdxLoc> {
	static __forceinline CXIdxLoc to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxLoc *>::to(res);
	}
};
template <> struct cast_arg<CXIdxIncludedFileInfo> {
	static __forceinline CXIdxIncludedFileInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxIncludedFileInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxImportedASTFileInfo> {
	static __forceinline CXIdxImportedASTFileInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxImportedASTFileInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxAttrInfo> {
	static __forceinline CXIdxAttrInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxAttrInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxEntityInfo> {
	static __forceinline CXIdxEntityInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxEntityInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxContainerInfo> {
	static __forceinline CXIdxContainerInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxContainerInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxIBOutletCollectionAttrInfo> {
	static __forceinline CXIdxIBOutletCollectionAttrInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxIBOutletCollectionAttrInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxDeclInfo> {
	static __forceinline CXIdxDeclInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCContainerDeclInfo> {
	static __forceinline CXIdxObjCContainerDeclInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCContainerDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxBaseClassInfo> {
	static __forceinline CXIdxBaseClassInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxBaseClassInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCProtocolRefInfo> {
	static __forceinline CXIdxObjCProtocolRefInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCProtocolRefInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCProtocolRefListInfo> {
	static __forceinline CXIdxObjCProtocolRefListInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCProtocolRefListInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCInterfaceDeclInfo> {
	static __forceinline CXIdxObjCInterfaceDeclInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCInterfaceDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCCategoryDeclInfo> {
	static __forceinline CXIdxObjCCategoryDeclInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCCategoryDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCPropertyDeclInfo> {
	static __forceinline CXIdxObjCPropertyDeclInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCPropertyDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxCXXClassDeclInfo> {
	static __forceinline CXIdxCXXClassDeclInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxCXXClassDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxEntityRefInfo> {
	static __forceinline CXIdxEntityRefInfo to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxEntityRefInfo *>::to(res);
	}
};
template <> struct cast_arg<IndexerCallbacks> {
	static __forceinline IndexerCallbacks to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<IndexerCallbacks *>::to(res);
	}
};
